<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>「UOJ34」多项式乘法</title>
      <link href="/2018/03/20/%E3%80%8CUOJ34%E3%80%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95/"/>
      <url>/2018/03/20/%E3%80%8CUOJ34%E3%80%8D%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个多项式，请输出乘起来后的多项式。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>快速傅里叶变换模板</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">400010</span>;</span><br><span class="line"><span class="keyword">const</span> db PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> n,m,tot,maxp,rev[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Com</span>&#123;</span></span><br><span class="line">    db real,image;</span><br><span class="line">    Com <span class="keyword">operator</span>+(<span class="keyword">const</span> Com&amp; k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> (Com)&#123;real+k.real,image+k.image&#125;;&#125;;</span><br><span class="line">    Com <span class="keyword">operator</span>-(<span class="keyword">const</span> Com&amp; k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> (Com)&#123;real-k.real,image-k.image&#125;;&#125;;</span><br><span class="line">    Com <span class="keyword">operator</span>*(<span class="keyword">const</span> Com&amp; k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> (Com)&#123;real*k.real-image*k.image,real*k.image+image*k.real&#125;;&#125;;</span><br><span class="line">    Com <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">int</span> k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> (Com)&#123;real/k,image/k&#125;;&#125;;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Com* a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(rev[i]&gt;i) swap(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        Com wn=(Com)&#123;<span class="built_in">cos</span>(<span class="number">2.0</span>*PI/len),<span class="built_in">sin</span>(<span class="number">2.0</span>*PI/len)*b&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">            Com w=(Com)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(len&gt;&gt;<span class="number">1</span>);j++,w=w*wn)&#123;</span><br><span class="line">                Com x=a[i+j],y=a[i+j+(len&gt;&gt;<span class="number">1</span>)]*w;</span><br><span class="line">                a[i+j]=x+y,a[i+j+(len&gt;&gt;<span class="number">1</span>)]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]/n;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i].real);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;b[i].real);</span><br><span class="line">    tot=n+m,n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&lt;=tot) n&lt;&lt;=<span class="number">1</span>,maxp++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(maxp<span class="number">-1</span>));</span><br><span class="line">    fft(a,<span class="number">1</span>);fft(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*b[i];</span><br><span class="line">    fft(a,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="keyword">int</span>(a[i].real+<span class="number">0.1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu1782」旅行商的背包</title>
      <link href="/2018/03/09/%E3%80%8Cluogu1782%E3%80%8D%E6%97%85%E8%A1%8C%E5%95%86%E7%9A%84%E8%83%8C%E5%8C%85/"/>
      <url>/2018/03/09/%E3%80%8Cluogu1782%E3%80%8D%E6%97%85%E8%A1%8C%E5%95%86%E7%9A%84%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>小S坚信任何问题都可以在多项式时间内解决，于是他准备亲自去当一回旅行商。在出发之前，他购进了一些物品。这些物品共有$n$种，第$i$种体积为$V_i$，价值为$W_i$，共有$D_i$件。他的背包体积是$C$。怎样装才能获得尽量多的收益呢？作为一名大神犇，他轻而易举的解决了这个问题。</p><p>然而，就在他出发前，他又收到了一批奇货。这些货共有$m$件，第$i$件的价值$Y_i$与分配的体积$X_i$之间的关系为: $Y_i=a_i ×  X_i^2 + b_i × X_i + c_i$。这是件好事，但小S却不知道怎么处理了，于是他找到了一位超级神犇（也就是你），请你帮他解决这个问题。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>普通物品部分是一个多重背包，令f[i][j]表示前$i$件物品，用容量$j$获得的最大价值，列出dp方程：</p><script type="math/tex; mode=display">f[i][j]=\max(f[i-1][j-k*V_i]+k*W_i)</script><p>时间复杂度$O(N^2C)$,无法满足题目要求，考虑单调队列优化。</p><p>经过观察，我们发现转移只发生在$j$在模$V_i$意义下相同的状态之间，所以把状态按照$j$模$V_i$的值分组，令$x=j%V_i$,dp方程可以改写成这样：</p><script type="math/tex; mode=display">f[i][j]=\max_{k\leq \frac{j-x}{V_i}}\{f[i-1][k*V_i+x]+(\frac{j-x}{V_i}-k)*W_i\}</script><p>（实还应当加入$D_i$的限制，但出于公式间接考虑略去了这部分。）</p><p>把$k*W_i$提出来</p><script type="math/tex; mode=display">f[i][j]=\max_{k\leq \frac{j-x}{V_i}}(f[i-1][k*V_i+x]+\frac{j-x}{V_i}*W_i)+k*W_i</script><p>max里的部分可以用单调队列优化。</p><p>因为这题$m$很小，第二部分直接用朴素方法就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cap,v[N],w[N],d[N],a[N],b[N],c[N],ans=<span class="number">0</span>,cnt[N];</span><br><span class="line">ll f[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,w=<span class="number">1</span>;<span class="keyword">char</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,h,nxt;</span><br><span class="line">    n=read(),m=read(),cap=read();</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) v[i]=read(),w[i]=read(),d[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) a[i]=read(),b[i]=read(),c[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(R <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v[i];j++)</span><br><span class="line">            <span class="keyword">for</span>(R <span class="keyword">int</span> k=<span class="number">0</span>,head=<span class="number">0</span>,tail=<span class="number">0</span>;k*v[i]+j&lt;=cap;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt=f[k*v[i]+j]-k*w[i];</span><br><span class="line">                <span class="keyword">if</span>(k-cnt[head]&gt;d[i]) head++;</span><br><span class="line">                <span class="keyword">while</span>(head&lt;tail&amp;&amp;q[tail<span class="number">-1</span>]&lt;nxt) tail--;</span><br><span class="line">                q[tail]=nxt,cnt[tail++]=k;</span><br><span class="line">                f[k*v[i]+j]=q[head]+k*w[i];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(R <span class="keyword">int</span> j=cap;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(R <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j;k++) f[j]=max(f[j],f[j-k]+a[i]*k*k+b[i]*k+c[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,f[cap]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu2596」[ZJOI2006]书架</title>
      <link href="/2018/03/09/%E3%80%8Cluogu2596%E3%80%8D%5BZJOI2006%5D%E4%B9%A6%E6%9E%B6/"/>
      <url>/2018/03/09/%E3%80%8Cluogu2596%E3%80%8D%5BZJOI2006%5D%E4%B9%A6%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个数列，要求提供5个操作：<br>(1)把一个数提到最前面。<br>(2)把一个数提到最后面。<br>(3)把一个数和它前面/后面的数交换。<br>(4)询问一个元素排第几。<br>(5)询问第X个元素的值。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>用splay维护数列。</p><p>对于(1)/(2)操作，将元素旋到根，然后将左子树合并到该元素的后继/前驱。</p><p>对于(3)操作，与这个元素的前驱/后继交换位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">80010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,maxpos,minpos,book[N&lt;&lt;<span class="number">2</span>],bookpos[N];</span><br><span class="line"><span class="keyword">int</span> root,fa[N&lt;&lt;<span class="number">2</span>],ch[N&lt;&lt;<span class="number">2</span>][<span class="number">2</span>],siz[N&lt;&lt;<span class="number">2</span>],pos[N&lt;&lt;<span class="number">2</span>],id[N&lt;&lt;<span class="number">2</span>],totnode;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,w=<span class="number">1</span>;<span class="keyword">char</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) x=x*<span class="number">10</span>+c<span class="number">-48</span>,c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    siz[k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch[k][<span class="number">0</span>]) siz[k]+=siz[ch[k][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">if</span>(ch[k][<span class="number">1</span>]) siz[k]+=siz[ch[k][<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> dad,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nownode=++totnode;</span><br><span class="line">    fa[nownode]=dad,pos[nownode]=mid,id[nownode]=book[mid];</span><br><span class="line">    ch[nownode][<span class="number">0</span>]=build(nownode,l,mid<span class="number">-1</span>),ch[nownode][<span class="number">1</span>]=build(nownode,mid+<span class="number">1</span>,r);</span><br><span class="line">    updata(nownode);</span><br><span class="line">    <span class="keyword">return</span> nownode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="keyword">return</span> ch[fa[k]][<span class="number">1</span>]==k;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old=fa[k],oldf=fa[old],whnow=which(k),whold=which(old);</span><br><span class="line">    ch[old][whnow]=ch[k][whnow^<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(ch[k][whnow^<span class="number">1</span>])fa[ch[k][whnow^<span class="number">1</span>]]=old;</span><br><span class="line">    fa[old]=k,ch[k][whnow^<span class="number">1</span>]=old,fa[k]=oldf;</span><br><span class="line">    <span class="keyword">if</span>(oldf) ch[oldf][whold]=k;</span><br><span class="line">    <span class="keyword">if</span>(!fa[k]) root=k;</span><br><span class="line">    updata(old);updata(k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fa[k];fa[k]!=aim;i=fa[k])</span><br><span class="line">        rotate(fa[i]!=aim&amp;&amp;which(k)==which(i)?i:k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//返回位置为x的书上面有多少本 </span></span><br><span class="line">    <span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos[k]==x)&#123;<span class="keyword">int</span> res=siz[ch[k][<span class="number">0</span>]];splay(k,<span class="number">0</span>);<span class="keyword">return</span> res;&#125;</span><br><span class="line">    <span class="keyword">if</span>(pos[k]&gt;x) <span class="keyword">return</span> find(ch[k][<span class="number">0</span>],x);</span><br><span class="line">    <span class="keyword">int</span> tmp=siz[ch[k][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">return</span> tmp+<span class="number">1</span>+find(ch[k][<span class="number">1</span>],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//返回第k本书的编号</span></span><br><span class="line">    <span class="keyword">if</span>(!now) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(siz[ch[now][<span class="number">0</span>]]==k<span class="number">-1</span>) <span class="keyword">return</span> id[now];</span><br><span class="line">    <span class="keyword">if</span>(siz[ch[now][<span class="number">0</span>]]&gt;=k) <span class="keyword">return</span> kth(ch[now][<span class="number">0</span>],k);</span><br><span class="line">    <span class="keyword">return</span> kth(ch[now][<span class="number">1</span>],k-siz[ch[now][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">bool</span> b)</span></span>&#123; <span class="comment">//b为0返回前驱节点，b为1返回后继节点 </span></span><br><span class="line">    <span class="keyword">if</span>(!ch[k][b]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now=ch[k][b];</span><br><span class="line">    <span class="keyword">while</span>(ch[now][b^<span class="number">1</span>]) now=ch[now][b^<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">bool</span> b)</span></span>&#123;</span><br><span class="line">    find(root,bookpos[s]);</span><br><span class="line">    pos[root]=bookpos[s]=b?++maxpos:--minpos;</span><br><span class="line">    <span class="keyword">if</span>(!ch[root][b]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!ch[root][b^<span class="number">1</span>])&#123;</span><br><span class="line">        swap(ch[root][<span class="number">0</span>],ch[root][<span class="number">1</span>]); <span class="comment">//!!</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    book[bookpos[s]]=s;</span><br><span class="line">    <span class="keyword">int</span> nxt=get(root,b^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!nxt)&#123;swap(ch[root][<span class="number">0</span>],ch[root][<span class="number">1</span>]);<span class="keyword">return</span>;&#125;</span><br><span class="line">    splay(nxt,root);</span><br><span class="line">    ch[nxt][b]=ch[root][b];</span><br><span class="line">    fa[ch[root][b]]=nxt,ch[root][b]=<span class="number">0</span>;</span><br><span class="line">    updata(ch[root][b^<span class="number">1</span>]);updata(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nodeswap</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">bool</span> b)</span></span>&#123;</span><br><span class="line">    find(root,bookpos[s]);</span><br><span class="line">    <span class="keyword">int</span> nxt=get(root,b);</span><br><span class="line">    <span class="keyword">if</span>(!nxt) <span class="keyword">return</span>;</span><br><span class="line">    swap(id[nxt],id[root]);</span><br><span class="line">    swap(book[pos[root]],book[pos[nxt]]);</span><br><span class="line">    swap(bookpos[id[nxt]],bookpos[id[root]]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> t1,t2;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    minpos=m+<span class="number">1</span>,maxpos=n+m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=n+m;i++) book[i]=read(),bookpos[book[i]]=i;</span><br><span class="line">    root=<span class="number">1</span>;build(<span class="number">0</span>,m+<span class="number">1</span>,n+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,opt);</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'T'</span>)&#123;</span><br><span class="line">            t1=read();move(t1,<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'B'</span>)&#123;</span><br><span class="line">            t1=read();move(t1,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'I'</span>)&#123;</span><br><span class="line">            t1=read(),t2=read();</span><br><span class="line">            <span class="keyword">if</span>(t2==<span class="number">-1</span>) nodeswap(t1,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t2==<span class="number">1</span>) nodeswap(t1,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'A'</span>)&#123;</span><br><span class="line">            t1=read();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find(root,bookpos[t1]));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            t1=read();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,kth(root,t1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「UOJ58」[WC2013]糖果公园</title>
      <link href="/2018/03/08/%E3%80%8CUOJ58%E3%80%8D-WC2013-%E7%B3%96%E6%9E%9C%E5%85%AC%E5%9B%AD/"/>
      <url>/2018/03/08/%E3%80%8CUOJ58%E3%80%8D-WC2013-%E7%B3%96%E6%9E%9C%E5%85%AC%E5%9B%AD/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一棵树，每个点有一个颜色$c_i$，每种颜色有一个美味指数$v_i$，$w_i$表示第$i$次遇到某种颜色时的新奇指数，实现下面两种操作：</p><p>1.询问两点间路径上的$\sum_{}^{} {v_{c_i}*w_j}$，$j$表示第$j$次遇到这种颜色。</p><p>2.修改某个点的颜色。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>树上带修改莫队。</p><p>用欧拉序转化为区间问题，然后就是一个带修改莫队啦。</p><p>注意LCA有特殊情况要处理。</p><p>代码略丑(AC的时候没感觉，第二次看的时候完全忍不了了好吗)，已加入重写计划。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>,P=<span class="number">20</span>,maxp=<span class="number">17</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">char</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,q,c[N],temp[N],id[N&lt;&lt;<span class="number">1</span>],totid,siz,bel[N],in[N],out[N],cnt[N];</span><br><span class="line"><span class="keyword">short</span> vis[N];</span><br><span class="line">ll v[N],w[N],ans[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line"><span class="keyword">int</span> f[N][P],dep[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Que</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,t,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Que&amp; k)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bel[l]==bel[k.l]&amp;&amp;bel[r]==bel[k.r]) <span class="keyword">return</span> t&lt;k.t;</span><br><span class="line">        <span class="keyword">return</span> bel[l]==bel[k.l]?r&lt;k.r:l&lt;k.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;que[N];</span><br><span class="line"><span class="keyword">int</span> totq,totc,from[N],to[N],pos[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    f[k][<span class="number">0</span>]=fa,id[++totid]=k,dep[k]=d,in[k]=totid;</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(x==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(x,k,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    id[++totid]=k,out[k]=totid;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getlca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxp;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxp;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt,t1,t2;</span><br><span class="line">    n=read(),m=read(),q=read(),siz=<span class="built_in">pow</span>(n,<span class="number">2.0</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) v[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) w[i]=read(),bel[i]=i/siz+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;t1=read(),t2=read();g[t1].push_back(t2);g[t2].push_back(t1);&#125;</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i]=read(),temp[i]=c[i];</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=maxp;j++)</span><br><span class="line">        <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        opt=read(),t1=read(),t2=read();</span><br><span class="line">        <span class="keyword">if</span>(!opt) ++totc,from[totc]=temp[t1],to[totc]=t2,pos[totc]=t1,temp[t1]=t2;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[t1]&gt;=in[t2]&amp;&amp;out[t1]&lt;=out[t2]||in[t2]&gt;=in[t1]&amp;&amp;out[t2]&lt;=out[t1]) que[++totq]=(Que)&#123;min(in[t1],in[t2]),max(in[t1],in[t2]),totc,totq&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(in[t1]-out[t2])&lt;<span class="built_in">abs</span>(out[t1]-in[t2])) que[++totq]=(Que)&#123;min(in[t1],out[t2]),max(in[t1],out[t2]),totc,totq&#125;;</span><br><span class="line">            <span class="keyword">else</span> que[++totq]=(Que)&#123;min(in[t2],out[t1]),max(in[t2],out[t1]),totc,totq&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(que+<span class="number">1</span>,que+totq+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> lca;</span><br><span class="line">    R <span class="keyword">int</span> x,pl=<span class="number">1</span>,pr=<span class="number">0</span>,pt=<span class="number">0</span>;</span><br><span class="line">    R ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totq;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pl&gt;que[i].l)&#123;</span><br><span class="line">            x=id[--pl];</span><br><span class="line">            <span class="keyword">if</span>(!vis[x]) vis[x]=<span class="number">1</span>,cnt[c[x]]++,res+=v[c[x]]*w[cnt[c[x]]];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vis[x]==<span class="number">1</span>) res-=v[c[x]]*w[cnt[c[x]]],vis[x]=<span class="number">2</span>,cnt[c[x]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pr&lt;que[i].r)&#123;</span><br><span class="line">            x=id[++pr];</span><br><span class="line">            <span class="keyword">if</span>(!vis[x]) vis[x]=<span class="number">1</span>,cnt[c[x]]++,res+=v[c[x]]*w[cnt[c[x]]];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vis[x]==<span class="number">1</span>) res-=v[c[x]]*w[cnt[c[x]]],vis[x]=<span class="number">2</span>,cnt[c[x]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pt&lt;que[i].t)&#123;</span><br><span class="line">            pt++;</span><br><span class="line">            x=pos[pt];</span><br><span class="line">            <span class="keyword">if</span>(vis[x]==<span class="number">1</span>) res-=v[c[x]]*w[cnt[c[x]]],cnt[c[x]]--;</span><br><span class="line">            c[x]=to[pt];</span><br><span class="line">            <span class="keyword">if</span>(vis[x]==<span class="number">1</span>) cnt[c[x]]++,res+=v[c[x]]*w[cnt[c[x]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pt&gt;que[i].t)&#123;</span><br><span class="line">            x=pos[pt];</span><br><span class="line">            <span class="keyword">if</span>(vis[x]==<span class="number">1</span>) res-=v[c[x]]*w[cnt[c[x]]],cnt[c[x]]--;</span><br><span class="line">            c[x]=from[pt];</span><br><span class="line">            <span class="keyword">if</span>(vis[x]==<span class="number">1</span>) cnt[c[x]]++,res+=v[c[x]]*w[cnt[c[x]]];</span><br><span class="line">            pt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pl&lt;que[i].l)&#123;</span><br><span class="line">            x=id[pl];</span><br><span class="line">            <span class="keyword">if</span>(vis[x]==<span class="number">2</span>) vis[x]=<span class="number">1</span>,cnt[c[x]]++,res+=v[c[x]]*w[cnt[c[x]]];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vis[x]==<span class="number">1</span>) res-=v[c[x]]*w[cnt[c[x]]],vis[x]=<span class="number">0</span>,cnt[c[x]]--;</span><br><span class="line">            pl++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pr&gt;que[i].r)&#123;</span><br><span class="line">            x=id[pr];</span><br><span class="line">            <span class="keyword">if</span>(vis[x]==<span class="number">2</span>) vis[x]=<span class="number">1</span>,cnt[c[x]]++,res+=v[c[x]]*w[cnt[c[x]]];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vis[x]==<span class="number">1</span>) res-=v[c[x]]*w[cnt[c[x]]],vis[x]=<span class="number">0</span>,cnt[c[x]]--;</span><br><span class="line">            pr--;</span><br><span class="line">        &#125;</span><br><span class="line">        lca=getlca(id[que[i].l],id[que[i].r]);</span><br><span class="line">        <span class="keyword">if</span>(lca==id[que[i].l]||lca==id[que[i].r]) ans[que[i].id]=res;</span><br><span class="line">        <span class="keyword">else</span> ans[que[i].id]=res+v[c[lca]]*w[cnt[c[lca]]+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(R <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totq;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ2120」数颜色</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ2120%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ2120%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>墨墨购买了一套$N$支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令：<br>1、 Q L R 代表询问你从第$L$支画笔到第$R$支画笔中共有几种不同颜色的画笔。<br>2、 R P Col 把第$P$支画笔替换为颜色$Col$。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>如果没有修改，我们可以通过区间[L,R]的答案快速求出区间[L-1,R],[L+1,R],[L,R-1],[L,R+1]的答案。</p><p>事实上，我们也可以O(1)的转移出修改前后的答案，即当我们知道[L,R,T]时，可以快速求出[L,R,T-1]和[L,R,T+1]。([L,R,T]表示第T次修改后区间[L,R]的答案)</p><p>这就相当于普通莫队多了一维。</p><p>具体可以这么实现:<br>(1) 把序列分为$n^{\frac{2}{3}}$个块，记$bel[i]$为$i$所在的块。<br>(2) 把询问的区间以$bel[l]$为第一关键字，$bel[r]$为第二关键字排序,t为第三关键字排序。<br>(3) 按排序后的顺序计算出答案即可。<br>*(4) 调参。</p><p>这个算法有个名字叫带修改莫队。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,C=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,siz,bel[N],color[N],temp[N],pos[N],from[N],to[N],cnt[C],totc,totq,ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Q</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,t,id;<span class="comment">//查询[l,r]在t次修改后的信息 </span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Q&amp; k)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bel[l]==bel[k.l]&amp;&amp;bel[r]==bel[k.r]) <span class="keyword">return</span> t&lt;k.t;</span><br><span class="line">        <span class="keyword">if</span>(bel[l]==bel[k.l]) <span class="keyword">return</span> r&lt;k.r;</span><br><span class="line">        <span class="keyword">return</span> l&lt;k.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;que[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> opt[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> t1,t2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    siz=<span class="built_in">pow</span>(n,<span class="number">2.0</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;color[i]),temp[i]=color[i],bel[i]=i/siz+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,opt,&amp;t1,&amp;t2);</span><br><span class="line">        <span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'Q'</span>) que[++totq]=(Q)&#123;t1,t2,totc,totq&#125;;</span><br><span class="line">        <span class="keyword">else</span> totc++,pos[totc]=t1,to[totc]=t2,from[totc]=temp[t1],temp[t1]=t2;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(que+<span class="number">1</span>,que+totq+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pl=<span class="number">1</span>,pr=<span class="number">0</span>,pt=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totq;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(pl&gt;que[i].l)&#123;</span><br><span class="line">            pl--;</span><br><span class="line">            cnt[color[pl]]++;</span><br><span class="line">            <span class="keyword">if</span>(cnt[color[pl]==<span class="number">1</span>]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pr&lt;que[i].r)&#123;</span><br><span class="line">            pr++;</span><br><span class="line">            cnt[color[pr]]++;</span><br><span class="line">            <span class="keyword">if</span>(cnt[color[pr]]==<span class="number">1</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pt&lt;que[i].t)&#123;</span><br><span class="line">            pt++;</span><br><span class="line">            <span class="keyword">if</span>(pos[pt]&lt;=pr&amp;&amp;pos[pt]&gt;=pl)&#123;</span><br><span class="line">                cnt[color[pos[pt]]]--;</span><br><span class="line">                <span class="keyword">if</span>(!cnt[color[pos[pt]]]) res--;</span><br><span class="line">            &#125; </span><br><span class="line">            color[pos[pt]]=to[pt];</span><br><span class="line">            <span class="keyword">if</span>(pos[pt]&lt;=pr&amp;&amp;pos[pt]&gt;=pl)&#123;</span><br><span class="line">                cnt[color[pos[pt]]]++;</span><br><span class="line">                <span class="keyword">if</span>(cnt[color[pos[pt]]]==<span class="number">1</span>) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pt&gt;que[i].t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos[pt]&lt;=pr&amp;&amp;pos[pt]&gt;=pl)&#123;</span><br><span class="line">                cnt[color[pos[pt]]]--;</span><br><span class="line">                <span class="keyword">if</span>(!cnt[color[pos[pt]]]) res--;</span><br><span class="line">            &#125;</span><br><span class="line">            color[pos[pt]]=from[pt];</span><br><span class="line">            <span class="keyword">if</span>(pos[pt]&lt;=pr&amp;&amp;pos[pt]&gt;=pl)&#123;</span><br><span class="line">                cnt[color[pos[pt]]]++;</span><br><span class="line">                <span class="keyword">if</span>(cnt[color[pos[pt]]]==<span class="number">1</span>) res++;</span><br><span class="line">            &#125;</span><br><span class="line">            pt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pl&lt;que[i].l)&#123;</span><br><span class="line">            cnt[color[pl]]--;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[color[pl]]) res--;</span><br><span class="line">            pl++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pr&gt;que[i].r)&#123;</span><br><span class="line">            cnt[color[pr]]--;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[color[pr]]) res--;</span><br><span class="line">            pr--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[que[i].id]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totq;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ2038」小Z的袜子</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ2038%E3%80%8D%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ2038%E3%80%8D%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个长度为$N$的颜色序列，从1到$N$编号。问在区间[L,R]中任选两个元素，这两个元素颜色相同的概率。有多次询问。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>想要得到答案，我们需要快速计算出区间内每种颜色的数量。</p><p>而当我们知道[L,R]的答案时，可以快速计算出[L-1,R],[L+1,R],[L,R-1],[L,R+1]的答案，这正是莫队算法擅长处理的情况！</p><p>莫队算法的步骤如下：<br>(1)把序列分为$\sqrt{n}$个块，记$bel[i]$为$i$所在的块。<br>(2)把询问的区间以$bel[l]$为第一关键字，$r$为第二关键字排序。<br>(3)按排序后的顺序计算出答案即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,c[N],bel[N],siz,cnt[N];</span><br><span class="line">ll ans1[N],ans2[N];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> y?gcd(y,x%y):x;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> bel[l]==bel[k.l]?r&lt;k.r:l&lt;k.l;&#125;</span><br><span class="line">&#125;que[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    siz=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]),bel[i]=i/siz+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;que[i].l,&amp;que[i].r),que[i].id=i;</span><br><span class="line">    sort(que+<span class="number">1</span>,que+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ql=<span class="number">1</span>,qr=<span class="number">0</span>;</span><br><span class="line">    ll sum1=<span class="number">0</span>,sum2=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(qr&lt;que[i].r)&#123;</span><br><span class="line">            qr++;</span><br><span class="line">            sum1+=<span class="number">2</span>*cnt[c[qr]],cnt[c[qr]]++;</span><br><span class="line">            sum2+=<span class="number">2</span>*len,len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ql&gt;que[i].l)&#123;</span><br><span class="line">            ql--;</span><br><span class="line">            sum1+=<span class="number">2</span>*cnt[c[ql]],cnt[c[ql]]++;</span><br><span class="line">            sum2+=<span class="number">2</span>*len,len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(qr&gt;que[i].r)&#123;</span><br><span class="line">            sum1-=<span class="number">2</span>*cnt[c[qr]]<span class="number">-2</span>,cnt[c[qr]]--;</span><br><span class="line">            sum2-=<span class="number">2</span>*len<span class="number">-2</span>,len--;</span><br><span class="line">            qr--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ql&lt;que[i].l)&#123;</span><br><span class="line">            sum1-=<span class="number">2</span>*cnt[c[ql]]<span class="number">-2</span>,cnt[c[ql]]--;</span><br><span class="line">            sum2-=<span class="number">2</span>*len<span class="number">-2</span>,len--;</span><br><span class="line">            ql++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(que[i].l==que[i].r||!sum1)</span><br><span class="line">            ans1[que[i].id]=<span class="number">0</span>,ans2[que[i].id]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll g=gcd(sum1,sum2);</span><br><span class="line">            ans1[que[i].id]=sum1/g,ans2[que[i].id]=sum2/g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,ans1[i],ans2[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ2879」[Noi2012]美食节</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ2879%E3%80%8D-Noi2012-%E7%BE%8E%E9%A3%9F%E8%8A%82/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ2879%E3%80%8D-Noi2012-%E7%BE%8E%E9%A3%9F%E8%8A%82/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>共有$n$道菜，$m$个厨师，给出每个厨师做每道菜的时间。现在有$p_i$个同学点了第$i$道菜，问如何安排做菜方案，使同学的总等待时间最短。如果一个同学点的菜是某个厨师做的第$k$道菜，则他的等待时间就是这个厨师制作前$k$道菜的时间之和。而总等待时间为所有同学的等待时间之和。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这道题就是<a href="http://blog.mycup.cc/2018/03/08/%E3%80%8CBZOJ1070%E3%80%8D-SCOI2007-%E4%BF%AE%E8%BD%A6/" target="_blank" rel="noopener">「BZOJ1070」[SCOI2007]修车</a>的加强版。</p><p>思路和做法都十分相似。</p><p>但是如果一开始把全部边连上会T。</p><p>我们发现每个厨师肯定会优先去走等待人数少的点，那么其他的边多出来就白白增加了跑spfa用的时间。</p><p>所以考虑动态连边，一开始只连最后做的菜，跑费用流的过程中连上下一条边。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50</span>,M=<span class="number">110</span>,NN=<span class="number">100010</span>,oo=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cost[N][M],tot,s,t,p[N],rank[NN],c[NN];</span><br><span class="line"><span class="keyword">bool</span> isend[NN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,flow,cap,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> edge_tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt;edge;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[NN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> cc,<span class="keyword">int</span> ww)</span></span>&#123;</span><br><span class="line">    edge.push_back((Edge)&#123;f,t,<span class="number">0</span>,cc,ww&#125;);</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    edge.push_back((Edge)&#123;t,f,<span class="number">0</span>,<span class="number">0</span>,-ww&#125;);</span><br><span class="line">    point[t].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[NN],pre[NN];</span><br><span class="line"><span class="keyword">bool</span> inq[NN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) dis[i]=oo;</span><br><span class="line">    q.push(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>,inq[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front();q.pop();</span><br><span class="line">        inq[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class="line">            Edge&amp; e=edge[point[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&lt;=e.flow) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+e.w&lt;dis[e.to])&#123;</span><br><span class="line">                dis[e.to]=dis[x]+e.w,pre[e.to]=point[x][i];</span><br><span class="line">                <span class="keyword">if</span>(!inq[e.to])&#123;inq[e.to]=<span class="number">1</span>;q.push(e.to);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]&lt;oo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincostmaxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,f,now;</span><br><span class="line">    <span class="keyword">while</span>(spfa())&#123;</span><br><span class="line">        f=oo,now=t;</span><br><span class="line">        <span class="keyword">while</span>(now!=s)&#123;</span><br><span class="line">            f=min(f,edge[pre[now]].cap-edge[pre[now]].flow);</span><br><span class="line">            <span class="keyword">if</span>(isend[now])&#123;</span><br><span class="line">                isend[now]=<span class="number">0</span>,isend[++tot]=<span class="number">1</span>,rank[tot]=rank[now]+<span class="number">1</span>,c[tot]=c[now];</span><br><span class="line">                add_edge(tot,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n+<span class="number">2</span>;i++) add_edge(i,tot,<span class="number">1</span>,rank[tot]*cost[i<span class="number">-2</span>][c[tot]]);</span><br><span class="line">            &#125;</span><br><span class="line">            now=edge[pre[now]].from;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=dis[t]*f,now=t;</span><br><span class="line">        <span class="keyword">while</span>(now!=s)&#123;</span><br><span class="line">            edge[pre[now]].flow+=f,edge[pre[now]^<span class="number">1</span>].flow-=f;</span><br><span class="line">            now=edge[pre[now]].from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cost[i][j]);</span><br><span class="line">    s=++tot,t=++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add_edge(s,++tot,p[i],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        add_edge(++tot,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        rank[tot]=<span class="number">1</span>,c[tot]=i,isend[tot]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">3</span>;j&lt;=n+<span class="number">2</span>;j++) add_edge(j,i+n+<span class="number">2</span>,<span class="number">1</span>,cost[j<span class="number">-2</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=mincostmaxflow();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ1834」[ZJOI2010]网络扩容</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ1834%E3%80%8D-ZJOI2010-%E7%BD%91%E7%BB%9C%E6%89%A9%E5%AE%B9/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ1834%E3%80%8D-ZJOI2010-%E7%BD%91%E7%BB%9C%E6%89%A9%E5%AE%B9/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一张有向图，每条边都有一个容量$C$和一个扩容费用$W$。这里扩容费用是指将容量扩大1所需的费用。求：<br>1、 在不扩容的情况下，1到N的最大流；<br>2、 将1到N的最大流增加K所需的最小扩容费用。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>第一问普通的最大流。</p><p>第二问考虑费用流：<br>(1)保留原图的残量网络。<br>(2)连出费用为扩容费用的边，容量为$k$。<br>(3)增加一个起点$s$向1连一条容量为$k$，费用为0的边。</p><p>保留原图的残量网络?因为扩容后除扩容的边其他边的流量不一定等于最大流时的流量，此时我们要发挥网络自动调整的功能。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">5010</span>,oo=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,s,t;</span><br><span class="line"><span class="keyword">int</span> level[N],edge_tot,edge_tot2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,flow,cap,w;</span><br><span class="line">&#125;edge[M&lt;&lt;<span class="number">1</span>],edge2[M&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[N],point2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> c,<span class="keyword">int</span> ww)</span></span>&#123;</span><br><span class="line">    edge[edge_tot]=(Edge)&#123;f,t,<span class="number">0</span>,c,ww&#125;;</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge2</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> ff,<span class="keyword">int</span> c,<span class="keyword">int</span> ww)</span></span>&#123;</span><br><span class="line">    edge2[edge_tot2]=(Edge)&#123;f,t,ff,c,ww&#125;;</span><br><span class="line">    point2[f].push_back(edge_tot2++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">0</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    level[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class="line">            Edge&amp; e=edge[point[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&lt;=e.flow||level[e.to]) <span class="keyword">continue</span>;</span><br><span class="line">            level[e.to]=level[e.from]+<span class="number">1</span>;</span><br><span class="line">            q.push(e.to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a||k==t) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> f,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(e.cap&lt;=e.flow||level[e.to]!=level[k]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(f=dfs(e.to,min(a,e.cap-e.flow)))&#123;</span><br><span class="line">            a-=f,ans+=f;</span><br><span class="line">            edge[point[k][i]].flow+=f;</span><br><span class="line">            edge[point[k][i]^<span class="number">1</span>].flow-=f;</span><br><span class="line">            <span class="keyword">if</span>(!a) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) </span><br><span class="line">        ans+=dfs(s,oo);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[N],pre[N];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">127</span>/<span class="number">2</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    q.push(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>,inq[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front();q.pop();</span><br><span class="line">        inq[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point2[x].size();i++)&#123;</span><br><span class="line">            Edge&amp; e=edge2[point2[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&lt;=e.flow) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[e.to]&gt;dis[x]+e.w)&#123;</span><br><span class="line">                dis[e.to]=dis[x]+e.w,pre[e.to]=point2[x][i];</span><br><span class="line">                <span class="keyword">if</span>(!inq[e.to])&#123;q.push(e.to);inq[e.to]=<span class="number">1</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]&lt;=<span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflowmincost</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now,ans=<span class="number">0</span>,f;</span><br><span class="line">    <span class="keyword">while</span>(spfa())&#123;</span><br><span class="line">        now=t,f=oo;</span><br><span class="line">        <span class="keyword">while</span>(now!=s)&#123;</span><br><span class="line">            f=min(f,edge2[pre[now]].cap-edge2[pre[now]].flow);</span><br><span class="line">            now=edge2[pre[now]].from;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f*dis[t],now=t;</span><br><span class="line">        <span class="keyword">while</span>(now!=s)&#123;</span><br><span class="line">            edge2[pre[now]].flow+=f,edge2[pre[now]^<span class="number">1</span>].flow-=f;</span><br><span class="line">            now=edge2[pre[now]].from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2,t3,t4;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;t1,&amp;t2,&amp;t3,&amp;t4);</span><br><span class="line">        add_edge(t1,t2,t3,t4);</span><br><span class="line">        add_edge(t2,t1,<span class="number">0</span>,-t4);</span><br><span class="line">    &#125;</span><br><span class="line">    s=<span class="number">1</span>,t=n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,dinic());</span><br><span class="line">    s=n+<span class="number">1</span>;</span><br><span class="line">    add_edge2(s,<span class="number">1</span>,<span class="number">0</span>,k,<span class="number">0</span>);add_edge2(<span class="number">1</span>,s,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(e.cap&gt;e.flow)&#123;</span><br><span class="line">            add_edge2(e.from,e.to,e.flow,e.cap,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        add_edge2(e.from,e.to,<span class="number">0</span>,k,e.w);</span><br><span class="line">        add_edge2(e.to,e.from,<span class="number">0</span>,<span class="number">0</span>,-e.w);</span><br><span class="line">        e=edge[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">        add_edge2(e.from,e.to,e.flow,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,maxflowmincost());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ1935」[SHOI2007]园丁的烦恼</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ1935%E3%80%8D-SHOI2007-%E5%9B%AD%E4%B8%81%E7%9A%84%E7%83%A6%E6%81%BC/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ1935%E3%80%8D-SHOI2007-%E5%9B%AD%E4%B8%81%E7%9A%84%E7%83%A6%E6%81%BC/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给$n$个点的坐标，有$m$次询问，询问某一个矩阵内有多少个点。(0≤n≤500000,1≤m≤500000)<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>经典的二维偏序问题。</p><p>我也不知道为什么当时脑抽以为是三维偏序的。</p><p>其实一发树状数组就可以水过啦。</p><p>但由于我当时很脑抽，写了CDQ分治。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500010</span>,K=<span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,maxy,totq,ans[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,w=<span class="number">1</span>;<span class="keyword">char</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) w=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> type,x,y,v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; k)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==k.x&amp;&amp;y==k.y) <span class="keyword">return</span> type&lt;k.type;</span><br><span class="line">        <span class="keyword">if</span>(y==k.y) <span class="keyword">return</span> x&lt;k.x;</span><br><span class="line">        <span class="keyword">return</span> y&lt;k.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;que[N*<span class="number">5</span>],temp[N*<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; x,<span class="keyword">const</span> Node&amp; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.x==y.x&amp;&amp;x.y==y.y) <span class="keyword">return</span> x.type&lt;y.type;</span><br><span class="line">    <span class="keyword">if</span>(x.x==y.x) <span class="keyword">return</span> x.y&lt;y.y;</span><br><span class="line">    <span class="keyword">return</span> x.x&lt;y.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    cdq(l,mid);cdq(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> pi=l,pj=mid+<span class="number">1</span>,pt=l,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pi&lt;=mid&amp;&amp;pj&lt;=r)</span><br><span class="line">        <span class="keyword">if</span>(que[pi]&lt;que[pj])&#123;</span><br><span class="line">            <span class="keyword">if</span>(que[pi].type==<span class="number">1</span>) sum++;</span><br><span class="line">            temp[pt++]=que[pi++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(que[pj].type&gt;<span class="number">1</span>) ans[que[pj].v]+=(que[pj].type==<span class="number">2</span>?<span class="number">1</span>:<span class="number">-1</span>)*sum;</span><br><span class="line">            temp[pt++]=que[pj++];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(pi&lt;=mid) temp[pt++]=que[pi++];</span><br><span class="line">    <span class="keyword">while</span>(pj&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(que[pj].type&gt;<span class="number">1</span>) ans[que[pj].v]+=(que[pj].type==<span class="number">2</span>?<span class="number">1</span>:<span class="number">-1</span>)*sum;</span><br><span class="line">        temp[pt++]=que[pj++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) que[i]=temp[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2,t3,t4;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        t1=read(),t2=read(),t1++,t2++,maxy=max(maxy,t2);</span><br><span class="line">        que[++totq]=(Node)&#123;<span class="number">1</span>,t1,t2,<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        t1=read(),t2=read(),t3=read(),t4=read();</span><br><span class="line">        t1++,t2++,t3++,t4++;</span><br><span class="line">        <span class="keyword">if</span>(t2&gt;<span class="number">1e7</span>+<span class="number">1</span>||t1&gt;<span class="number">1e7</span>+<span class="number">1</span>||t3&lt;<span class="number">1</span>||t4&lt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        t1=max(t1,<span class="number">1</span>);t2=max(t2,<span class="number">1</span>);</span><br><span class="line">        t3=min(t3,<span class="keyword">int</span>(<span class="number">1e7</span>)+<span class="number">1</span>);</span><br><span class="line">        t4=min(t4,<span class="keyword">int</span>(<span class="number">1e7</span>)+<span class="number">1</span>);</span><br><span class="line">        maxy=max(maxy,max(t2,t4));</span><br><span class="line">        que[++totq]=(Node)&#123;<span class="number">2</span>,t3,t4,i&#125;;</span><br><span class="line">        <span class="keyword">if</span>(t1&gt;<span class="number">1</span>&amp;&amp;t2&gt;<span class="number">1</span>) que[++totq]=(Node)&#123;<span class="number">2</span>,t1<span class="number">-1</span>,t2<span class="number">-1</span>,i&#125;;</span><br><span class="line">        <span class="keyword">if</span>(t2&gt;<span class="number">1</span>) que[++totq]=(Node)&#123;<span class="number">3</span>,t3,t2<span class="number">-1</span>,i&#125;;</span><br><span class="line">        <span class="keyword">if</span>(t1&gt;<span class="number">1</span>) que[++totq]=(Node)&#123;<span class="number">3</span>,t1<span class="number">-1</span>,t4,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(que+<span class="number">1</span>,que+totq+<span class="number">1</span>,cmp);</span><br><span class="line">    cdq(<span class="number">1</span>,totq);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>【BZOJ3262】陌上花开</title>
      <link href="/2018/03/08/%E3%80%90BZOJ3262%E3%80%91%E9%99%8C%E4%B8%8A%E8%8A%B1%E5%BC%80/"/>
      <url>/2018/03/08/%E3%80%90BZOJ3262%E3%80%91%E9%99%8C%E4%B8%8A%E8%8A%B1%E5%BC%80/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$n$朵花,每朵花有三个属性:$S$、$C$、$M$,用三个整数表示。</p><p>一朵花的级别是它拥有的美丽能超过的花的数量。</p><p>定义一朵花A比另一朵花B要美丽,当且仅$S_a&gt;=S_b,C_a&gt;=C_b,M_a&gt;=M_b$。</p><p>显然,两朵花可能有同样的属性。需要统计出评出每个等级的花的数量。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>三元偏序问题模板</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>,K=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,cnt[N],ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; k)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==k.b&amp;&amp;c==k.c) <span class="keyword">return</span> a&lt;=k.a;</span><br><span class="line">        <span class="keyword">if</span>(b==k.b) <span class="keyword">return</span> c&lt;=k.c;</span><br><span class="line">        <span class="keyword">return</span> b&lt;=k.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[N],temp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; x,<span class="keyword">const</span> Node&amp; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.a==y.a&amp;&amp;x.b==y.b) <span class="keyword">return</span> x.c&lt;y.c;</span><br><span class="line">    <span class="keyword">if</span>(x.a==y.a) <span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">    <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="keyword">return</span> k&amp;(-k);&#125;</span><br><span class="line"><span class="keyword">int</span> tree[K],vis[K],timer;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos&lt;=k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[pos]!=timer) vis[pos]=timer,tree[pos]=<span class="number">0</span>;</span><br><span class="line">        tree[pos]+=x,pos+=lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[pos]!=timer) vis[pos]=timer,tree[pos]=<span class="number">0</span>;</span><br><span class="line">        res+=tree[pos],pos-=lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    cdq(l,mid);cdq(mid+<span class="number">1</span>,r);</span><br><span class="line">    timer++;</span><br><span class="line">    <span class="keyword">int</span> pi=l,pj=mid+<span class="number">1</span>,x=l,pp;</span><br><span class="line">    <span class="keyword">while</span>(pi&lt;=mid&amp;&amp;pj&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node[pi]&lt;node[pj])&#123;</span><br><span class="line">            add(node[pi].c,<span class="number">1</span>);</span><br><span class="line">            temp[x++]=node[pi++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[node[pj].id]+=que(node[pj].c);</span><br><span class="line">            pp=pi<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(pp&gt;=l&amp;&amp;node[pp].a==node[pj].a&amp;&amp;node[pp].b==node[pj].b&amp;&amp;node[pp].c==node[pj].c) ans[node[pp--].id]++;</span><br><span class="line">            temp[x++]=node[pj++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pi&lt;=mid) temp[x++]=node[pi++];</span><br><span class="line">    <span class="keyword">while</span>(pj&lt;=r)&#123;</span><br><span class="line">        ans[node[pj].id]+=que(node[pj].c);</span><br><span class="line">        pp=mid;</span><br><span class="line">        <span class="keyword">while</span>(pp&gt;=l&amp;&amp;node[pp].a==node[pj].a&amp;&amp;node[pp].b==node[pj].b&amp;&amp;node[pp].c==node[pj].c) ans[node[pp--].id]++;</span><br><span class="line">        temp[x++]=node[pj++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) node[i]=temp[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2,t3;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t1,&amp;t2,&amp;t3),node[i]=(Node)&#123;t1,t2,t3,i&#125;;</span><br><span class="line">    sort(node+<span class="number">1</span>,node+n+<span class="number">1</span>,cmp);</span><br><span class="line">    cdq(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[ans[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu2664」树上游戏</title>
      <link href="/2018/03/08/%E3%80%8Cluogu2664%E3%80%8D%E6%A0%91%E4%B8%8A%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/03/08/%E3%80%8Cluogu2664%E3%80%8D%E6%A0%91%E4%B8%8A%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一棵树，树的每个节点有个颜色。定义$s(i,j)$为$i$到$j$的颜色数量，以及</p><script type="math/tex; mode=display">sum_i=\sum_{j=1}^{n} s(i,j)</script><p>求所有的$sum[i]$。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>,oo=INT_MAX;</span><br><span class="line"><span class="keyword">int</span> n,color[N],cnt[N],cnt2[N],sub[N],nowchild;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line"><span class="keyword">int</span> f[N],siz[N],root,tot_node,sumsiz[N],cursumsiz[N];</span><br><span class="line"><span class="keyword">int</span> timer,timer2,colorvis[N],curcolorvis[N],isfirst[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[k]=<span class="number">1</span>,f[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(x==fa||vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        getroot(x,k);</span><br><span class="line">        siz[k]+=siz[x],f[k]=max(f[k],siz[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[k]=max(f[k],tot_node-siz[k]);</span><br><span class="line">    <span class="keyword">if</span>(f[root]&gt;f[k]) root=k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(x==fa||vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs0(x,k);</span><br><span class="line">        siz[k]+=siz[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(cnt[color[k]]==<span class="number">1</span>&amp;&amp;fa)&#123;</span><br><span class="line">        <span class="keyword">if</span>(colorvis[color[k]]!=timer) colorvis[color[k]]=timer,sumsiz[color[k]]=<span class="number">0</span>;</span><br><span class="line">        sumsiz[color[k]]+=siz[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(x==fa||vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        cnt[color[x]]++;</span><br><span class="line">        getsum(x,k);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[color[k]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fix</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(isfirst[k]==timer)&#123;</span><br><span class="line">        sub[k]-=sumsiz[color[k]]-cursumsiz[color[k]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(x==fa||vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fix(x,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(cnt[color[k]]==<span class="number">1</span>&amp;&amp;fa)&#123;</span><br><span class="line">        isfirst[k]=timer;</span><br><span class="line">        <span class="keyword">if</span>(curcolorvis[color[k]]!=timer2) curcolorvis[color[k]]=timer2,cursumsiz[color[k]]=<span class="number">0</span>;</span><br><span class="line">        sub[k]+=tot_node-siz[nowchild],sub[r]+=siz[k],sub[nowchild]-=siz[k];</span><br><span class="line">        cursumsiz[color[k]]+=siz[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(x==fa||vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!fa) nowchild=x,timer2++;</span><br><span class="line">        cnt[color[x]]++;</span><br><span class="line">        dfs1(x,k,r);</span><br><span class="line">        <span class="keyword">if</span>(!fa) fix(x,k);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[color[k]]--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    sum[k]+=sub[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(x==fa||vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        sub[x]+=sub[k];</span><br><span class="line">        dfs2(x,k);</span><br><span class="line">    &#125;</span><br><span class="line">    sub[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    timer++;</span><br><span class="line">    dfs0(k,<span class="number">0</span>);</span><br><span class="line">    cnt[color[k]]++;</span><br><span class="line">    getsum(k,<span class="number">0</span>);</span><br><span class="line">    cnt[color[k]]++;</span><br><span class="line">    dfs1(k,<span class="number">0</span>,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        sub[x]+=tot_node-siz[x];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[k]+=tot_node;</span><br><span class="line">    dfs2(k,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    vis[k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    calc(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        root=<span class="number">0</span>,tot_node=siz[x];</span><br><span class="line">        getroot(x,<span class="number">0</span>);</span><br><span class="line">        work(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2;</span><br><span class="line">    f[<span class="number">0</span>]=oo;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;color[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t1,&amp;t2);</span><br><span class="line">        g[t1].push_back(t2);g[t2].push_back(t1);</span><br><span class="line">    &#125;</span><br><span class="line">    root=<span class="number">0</span>,tot_node=n;</span><br><span class="line">    getroot(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    work(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ2152」聪聪可可</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ2152%E3%80%8D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ2152%E3%80%8D%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一棵带边权的树，任意选取两个点，求它们之间的路径边权和为3的倍数的概率。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>相当于求边权和为3的倍数的路径条数。</p><p>考虑点分治。</p><p>选取根后，分别统计出每个子树中到根的距离mod 3为0，1，2的节点个数，计算答案即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20010</span>,oo=INT_MAX;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> tot,root,f[N],siz[N],dep_cnt[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,len;</span><br><span class="line">    Edge(<span class="keyword">int</span> _to=<span class="number">0</span>,<span class="keyword">int</span> _len=<span class="number">0</span>):to(_to),len(_len)&#123;&#125;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> edge_tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    edge[edge_tot]=Edge(t,l);</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[k]=<span class="number">0</span>,siz[k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(e.to==fa||vis[e.to]) <span class="keyword">continue</span>;</span><br><span class="line">        getroot(e.to,k);</span><br><span class="line">        siz[k]+=siz[e.to];</span><br><span class="line">        f[k]=max(f[k],siz[e.to]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[k]=max(f[k],tot-siz[k]);</span><br><span class="line">    <span class="keyword">if</span>(f[root]&gt;f[k]) root=k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    dep_cnt[d]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(e.to==fa||vis[e.to]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(e.to,k,(d+e.len)%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep_cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep_cnt));dfs(k,<span class="number">0</span>,d);</span><br><span class="line">    <span class="keyword">return</span> dep_cnt[<span class="number">0</span>]*(dep_cnt[<span class="number">0</span>]<span class="number">-1</span>)+<span class="number">2</span>*dep_cnt[<span class="number">1</span>]*dep_cnt[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    vis[k]=<span class="number">1</span>;</span><br><span class="line">    ans+=calc(k,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(vis[e.to]) <span class="keyword">continue</span>;</span><br><span class="line">        ans-=calc(e.to,e.len);</span><br><span class="line">        root=<span class="number">0</span>,tot=siz[e.to];</span><br><span class="line">        getroot(e.to,<span class="number">0</span>);</span><br><span class="line">        work(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2,t3;</span><br><span class="line">    f[<span class="number">0</span>]=oo;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        add_edge(t1,t2,t3%<span class="number">3</span>);</span><br><span class="line">        add_edge(t2,t1,t3%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    root=<span class="number">0</span>,tot=n;</span><br><span class="line">    getroot(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    work(root);</span><br><span class="line">    ans+=n;</span><br><span class="line">    <span class="keyword">int</span> ans2=n*n,g=gcd(ans,ans2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/%d"</span>,ans/g,ans2/g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「POJ1741」Tree</title>
      <link href="/2018/03/08/%E3%80%8CPOJ1741%E3%80%8DTree/"/>
      <url>/2018/03/08/%E3%80%8CPOJ1741%E3%80%8DTree/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一棵带边权的树，求有多少点对之间距离小于等于$k$。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>所谓点分治，就是每次选取一个根，把树分为几棵子树和一个根，于是一个树上问题就被分解为子树内的子问题和一个与根有关的问题，这样递归下去，直到问题解决。</p><p>以这题为例，“与根有关的问题” 就是求经过根节点且距离小于等于$k$的路径条数。</p><p>具体求法是dfs一遍把每个节点距根的距离放进一个数组排序一下，再拿两个指针扫一遍统计出答案，当然这样会把起点和终点在同一子树的不合法路径算进去，我们需要减去这些路径。</p><p>这样我们就成功的分解了这个问题。</p><p>为了不使时间复杂度退化，我们每次选取树的重心为根。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,oo=INT_MAX;</span><br><span class="line"><span class="keyword">int</span> n,maxd,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,len,nxt;</span><br><span class="line">    Edge(<span class="keyword">int</span> _to=<span class="number">0</span>,<span class="keyword">int</span> _len=<span class="number">0</span>,<span class="keyword">int</span> _nxt=<span class="number">0</span>):to(_to),len(_len),nxt(_nxt)&#123;&#125;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> last[N],edge_tot;</span><br><span class="line"><span class="keyword">int</span> siz[N],root,f[N],tot,dep[N],dep_tot;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">    edge[++edge_tot]=Edge(t,l,last[f]);</span><br><span class="line">    last[f]=edge_tot;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[k]=<span class="number">1</span>,f[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[k];i;i=edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to==fa||vis[edge[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">        getroot(edge[i].to,k);</span><br><span class="line">        siz[k]+=siz[edge[i].to];</span><br><span class="line">        f[k]=max(f[k],siz[edge[i].to]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[k]=max(f[k],tot-siz[k]);</span><br><span class="line">    <span class="keyword">if</span>(f[k]&lt;f[root]) root=k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    dep[++dep_tot]=d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[k];i;i=edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to==fa||vis[edge[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(edge[i].to,k,d+edge[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    dep_tot=<span class="number">0</span>;dfs(k,<span class="number">0</span>,d);</span><br><span class="line">    sort(dep+<span class="number">1</span>,dep+dep_tot+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=dep_tot,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l;l&lt;r;l++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;dep[r]+dep[l]&gt;maxd) r--;</span><br><span class="line">        res+=r-l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    vis[k]=<span class="number">1</span>;</span><br><span class="line">    ans+=calc(k,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[k];i;i=edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[edge[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">        ans-=calc(edge[i].to,edge[i].len);</span><br><span class="line">        tot=siz[edge[i].to],root=<span class="number">0</span>;</span><br><span class="line">        getroot(edge[i].to,k);</span><br><span class="line">        work(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    ans=edge_tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2,t3;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t1,&amp;t2,&amp;t3);add_edge(t1,t2,t3);add_edge(t2,t1,t3);&#125;</span><br><span class="line">    root=<span class="number">0</span>,tot=n;</span><br><span class="line">    getroot(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    work(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    reset();</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=oo;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;maxd)) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ4031」[HEOI2015]小Z的房间</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ4031%E3%80%8D-HEOI2015-%E5%B0%8FZ%E7%9A%84%E6%88%BF%E9%97%B4/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ4031%E3%80%8D-HEOI2015-%E5%B0%8FZ%E7%9A%84%E6%88%BF%E9%97%B4/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个$n*m$的网格图，其中有一些点不可用，求可用点的生成树个数，答案对1000000000取模。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>矩阵树定理：<br>(1)记$d[i]$为点$i$的度数，图$G$的度数矩阵：</p><script type="math/tex; mode=display">D[i][j]= \begin{cases} d[i] & i=j\\ 0& i \neq j \end{cases}</script><p>(2)图$G$的邻接矩阵：</p><script type="math/tex; mode=display">A[i][j]= \begin{cases} 1 & \text{i与j之间有边}\\ 0& \text{i与j之间无边} \end{cases}</script><p>(3)图$G$的基尔霍夫(Kirchhoff)矩阵：</p><script type="math/tex; mode=display">C[i][j]=D[i][j]−A[i][j]</script><p>(4)图$G$的生成树个数等于其基尔霍夫矩阵$C$任何一个$n−1$阶主子式的行列式的绝对值。(所谓$n-1$阶主子式就是在矩阵中任意去掉标号相同的一行和一列以后剩下的子矩阵)</p><p>行列式直接求不好求，用高斯消元消成上三角再把对角线乘起来。</p><p>注意此题模数不是质数，消元时要用一种类似辗转相除的方法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,mod=<span class="number">1e9</span>,dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,id[<span class="number">15</span>][<span class="number">15</span>],cnt,w=<span class="number">1</span>;</span><br><span class="line">ll mat[N][N],ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    mat[f][t]-=<span class="number">1</span>,mat[f][f]+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++) mat[i][j]=(mat[i][j]+mod)%mod;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(mat[j][i])&#123;</span><br><span class="line">                ll temp=mat[i][i]/mat[j][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=cnt;k++)&#123;mat[i][k]=((mat[i][k]-temp*mat[j][k])%mod+mod)%mod;swap(mat[i][k],mat[j][k]);&#125;</span><br><span class="line">                w=-w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!mat[i][i]) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxtx,nxty;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">15</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="keyword">if</span>(c[j]==<span class="string">'.'</span>) id[i][j]=++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="keyword">if</span>(id[i][j])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)&#123;</span><br><span class="line">                nxtx=i+dx[d],nxty=j+dy[d];</span><br><span class="line">                <span class="keyword">if</span>(nxtx&gt;=<span class="number">1</span>&amp;&amp;nxtx&lt;=n&amp;&amp;nxty&gt;=<span class="number">1</span>&amp;&amp;nxty&lt;=m&amp;&amp;id[nxtx][nxty]) add_edge(id[i][j],id[nxtx][nxty]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt--;</span><br><span class="line">    gauss();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) ans=(ans*mat[i][i])%mod;</span><br><span class="line">    ans=((ans*w)%mod+mod)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「POJ2947」Widget Factory</title>
      <link href="/2018/03/08/%E3%80%8CPOJ2947%E3%80%8DWidget%20Factory/"/>
      <url>/2018/03/08/%E3%80%8CPOJ2947%E3%80%8DWidget%20Factory/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$n$种零件，每种零件的加工时间最少为3天最多为9天，给出$m$个工程用的时间和加工的零件数，求每种零件的加工时间。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>列出$m$个方程，用高斯消元求解。</p><p>需要判断无解和多解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>,mod=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,inv[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> mat[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getday</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'M'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'T'</span>) <span class="keyword">return</span> s[<span class="number">1</span>]==<span class="string">'U'</span>?<span class="number">2</span>:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'W'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'F'</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'S'</span>) <span class="keyword">return</span> s[<span class="number">1</span>]==<span class="string">'A'</span>?<span class="number">6</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123; <span class="comment">//无解返回0，多解返回-1，唯一解返回1 </span></span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">1</span>,nxt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        nxt=<span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=now;j&lt;=m;j++) <span class="keyword">if</span>(mat[j][i])&#123;nxt=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(nxt==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(nxt!=now) <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n+<span class="number">1</span>;j++) swap(mat[now][j],mat[nxt][j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=now+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=mat[j][i]*inv[mat[now][i]]%mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n+<span class="number">1</span>;k++) mat[j][k]=((mat[j][k]-temp*mat[now][k])%mod+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        now++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="keyword">if</span>(mat[i][n+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(mat[i][j])&#123;flag=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now&lt;=n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        mat[i][n+<span class="number">1</span>]=mat[i][n+<span class="number">1</span>]*inv[mat[i][i]]%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;j++) mat[j][n+<span class="number">1</span>]=((mat[j][n+<span class="number">1</span>]-mat[j][i]*mat[i][n+<span class="number">1</span>])%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">if</span>(mat[i][n+<span class="number">1</span>]&lt;<span class="number">3</span>) mat[i][n+<span class="number">1</span>]+=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t1,k;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">10</span>],s2[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%s%s"</span>,&amp;k,s1,s2);</span><br><span class="line">        mat[i][n+<span class="number">1</span>]=(getday(s2)-getday(s1)+<span class="number">8</span>)%<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t1),mat[i][t1]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) mat[i][j]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=gauss();</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="built_in">printf</span>(<span class="string">"Inconsistent data.\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"Multiple solutions.\n"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,mat[i][n+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mat[n][n+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mat,<span class="number">0</span>,<span class="keyword">sizeof</span>(mat));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">7</span>;i++) inv[i]=<span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">1.0</span>*i,<span class="number">5</span>))%<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「POJ2942」Knights of the Round Table</title>
      <link href="/2018/03/08/%E3%80%8CPOJ2942%E3%80%8DKnights%20of%20the%20Round%20Table/"/>
      <url>/2018/03/08/%E3%80%8CPOJ2942%E3%80%8DKnights%20of%20the%20Round%20Table/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>亚瑟王要召开圆桌骑士会议，但骑士之间有的关系不好，关系不好的不能相邻。开会骑士的个数需要为奇数且不小于三。求至少要踢掉几个骑士。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>把能坐在一起的连边。</p><p>因为座位是一个环，对应图中的点双连通分量。</p><p>求出点双连通分量后，再黑白染色判一下是否存在奇环。若存在，则这里面的点是可行的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>,M=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,color[N];</span><br><span class="line"><span class="keyword">bool</span> hate[N][N],can[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],timer,cnt,sta[N],top;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tog[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dfn[k]=low[k]=++timer;</span><br><span class="line">    sta[top++]=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!hate[k][i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa==i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            tarjan(i,k);</span><br><span class="line">            low[k]=min(low[k],low[i]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[k]&lt;=low[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">while</span>(sta[top]!=i) top--,tog[cnt].push_back(sta[top]);;</span><br><span class="line">                tog[cnt].push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dfn[k]&gt;dfn[i]) low[k]=min(low[k],dfn[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fa)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">while</span>(top)&#123;top--;tog[cnt].push_back(sta[top]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tog[k].size();i++) <span class="keyword">if</span>(tog[k][i]==x)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tog[k].size()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(tog[k][<span class="number">0</span>]);</span><br><span class="line">    color[tog[k][<span class="number">0</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!hate[now][i]&amp;&amp;pd(k,i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">                color[i]=<span class="number">-1</span>*color[now];</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[i]==color[now]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) tog[i].clear();</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(hate,<span class="number">0</span>,<span class="keyword">sizeof</span>(hate));</span><br><span class="line">    <span class="built_in">memset</span>(can,<span class="number">0</span>,<span class="keyword">sizeof</span>(can));</span><br><span class="line">    cnt=timer=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t1,t2,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t1,&amp;t2),hate[t1][t2]=hate[t2][t1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) hate[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(check(i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tog[i].size();j++) can[tog[i][j]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!can[i]) ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    reset();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ2730」[HNOI2012]矿场搭建</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ2730%E3%80%8D-HNOI2012-%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ2730%E3%80%8D-HNOI2012-%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个无向图，需要在某些点设立出口，使无论删除图中的哪个点，图中的每个联通块中至少存在一个出口，求至少设置几个出口，以及设置的方案总数。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>如果删除的点不是割点，那么只要设置两个及以上的出口就一定能出去。</p><p>如果是割点的话就会分离出一个联通块。</p><p>因此我们求出所有割点，dfs一遍整个图。</p><p>一个联通块会被分离当且仅当它周围只有一个割点，在这种联通块里设立一个出口即可。</p><p>注意处理特殊情况，当一个图中没有割点时要设立两个出口。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,T,ans1,cnt,siz,dfn[N],low[N],timer;</span><br><span class="line">ll ans2;</span><br><span class="line"><span class="keyword">bool</span> vis[N],iscut[N],viscut[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to;</span><br><span class="line">    Edge(<span class="keyword">int</span> _from=<span class="number">0</span>,<span class="keyword">int</span> _to=<span class="number">0</span>):from(_from),to(_to)&#123;&#125;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[N];</span><br><span class="line"><span class="keyword">int</span> edge_tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    edge[edge_tot]=Edge(f,t);</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ff[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    ff[k]=fa;</span><br><span class="line">    <span class="keyword">int</span> child=<span class="number">0</span>;</span><br><span class="line">    dfn[k]=low[k]=++timer;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=point[k].size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[e.to])&#123;</span><br><span class="line">            child++;</span><br><span class="line">            tarjan(e.to,k);</span><br><span class="line">            low[k]=min(low[k],low[e.to]);</span><br><span class="line">            <span class="keyword">if</span>(low[e.to]&gt;=dfn[k]) iscut[k]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dfn[e.to]&lt;dfn[k]&amp;&amp;e.to!=fa) low[k]=min(dfn[e.to],low[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fa&amp;&amp;child==<span class="number">1</span>) iscut[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">    vis[k]=<span class="number">1</span>,siz++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(iscut[e.to]&amp;&amp;!viscut[e.to]) viscut[e.to]=<span class="number">1</span>,cnt++;</span><br><span class="line">        <span class="keyword">if</span>(iscut[e.to]||pre==e.to||vis[e.to])<span class="keyword">continue</span>;</span><br><span class="line">        dfs(e.to,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2,tot=<span class="number">0</span>;</span><br><span class="line">    ans1=edge_tot=<span class="number">0</span>,ans2=<span class="number">1</span>,timer=<span class="number">0</span>;</span><br><span class="line">    T++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t1,&amp;t2);add_edge(t1,t2);add_edge(t2,t1);tot=max(tot,max(t1,t2));&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) <span class="keyword">if</span>(!dfn[i]) tarjan(i,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) <span class="keyword">if</span>(!iscut[i]&amp;&amp;!vis[i])&#123;</span><br><span class="line">        cnt=siz=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(viscut,<span class="number">0</span>,<span class="keyword">sizeof</span>(viscut));</span><br><span class="line">        dfs(i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!cnt) ans1+=<span class="number">2</span>,ans2*=siz*(siz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>) ans1++,ans2*=siz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d: %d %lld\n"</span>,T,ans1,ans2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) point[i].clear();</span><br><span class="line">    <span class="built_in">memset</span>(iscut,<span class="number">0</span>,<span class="keyword">sizeof</span>(iscut));<span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「POJ3352」Road Construction</title>
      <link href="/2018/03/08/%E3%80%8CPOJ3352%E3%80%8DRoad%20Construction/"/>
      <url>/2018/03/08/%E3%80%8CPOJ3352%E3%80%8DRoad%20Construction/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个无向图，问要添加几条边才能使这个图变为边双联通图。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>求出边双连通分量，缩点后成为一个树。</p><p>然后用到这个结论：<br>若要使得任意一棵树，在增加若干条边后，变成一个双连通图，那么 至少增加的边数=(叶子结点数+1)/2。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],timer,sta[N],top,cnt,d[N],ans,color[N];</span><br><span class="line"><span class="keyword">bool</span> gg[N][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dfn[k]=low[k]=++timer;</span><br><span class="line">    sta[top++]=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[k].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=g[k][i];</span><br><span class="line">        <span class="keyword">if</span>(x==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[x])&#123;</span><br><span class="line">            tarjan(x,k);</span><br><span class="line">            low[k]=min(low[k],low[x]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dfn[x]&lt;dfn[k]) low[k]=min(low[k],dfn[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[k]==dfn[k])&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">while</span>(sta[top]!=k) top--,color[sta[top]]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t1,&amp;t2);</span><br><span class="line">        g[t1].push_back(t2);g[t2].push_back(t1);</span><br><span class="line">    &#125;</span><br><span class="line">    tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=g[i][j];</span><br><span class="line">            <span class="keyword">if</span>(color[x]!=color[i]&amp;&amp;!gg[color[i]][color[x]])</span><br><span class="line">                d[color[x]]++,d[color[i]]++,gg[color[i]][color[x]]=gg[color[x]][color[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(d[i]==<span class="number">1</span>) ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,(ans+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ3572」[HNOI2014]世界树</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ3572%E3%80%8D-HNOI2014-%E4%B8%96%E7%95%8C%E6%A0%91/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ3572%E3%80%8D-HNOI2014-%E4%B8%96%E7%95%8C%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一棵$n$节点树，q次询问，每次询问钦定$m_i$个点，树上每个节点被离其最近的钦定点管辖，问每个钦定点要管辖多少个节点。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="*数据范围"></a>*数据范围</h3><p>$n\leq$300000, $q\leq$300000,$m_1+m_2+…+m_q\leq$300000<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>注意数据范围，不难看出要构出虚树。</p><p>先求出虚树上的每个点被哪个点管辖，用两遍dp实现。先用儿子向上更新，再用父亲向下更新(顺序不能颠倒，否则无法处理管辖兄弟的情况)。</p><p>然后考虑虚树边上的点，分两种情况：<br>    (1)若虚树边两端被同一个点管辖，那么这条边上的所有点都被这个点管辖。<br>    (2)否则虚树边上存在一个分界点，分界点两侧分别被那边的点管辖，我们可以倍增地找到这个分界点。</p><p>统计答案即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">300010</span>,P=<span class="number">25</span>,oo=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,a[N];</span><br><span class="line"><span class="keyword">int</span> fa[N][P],dep[N],id[N],siz[N],dfn;</span><br><span class="line"><span class="keyword">int</span> ans[N],b[N],c[N],f[N],d[N],w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,v,next;</span><br><span class="line">    Edge(<span class="keyword">int</span> _from=<span class="number">0</span>,<span class="keyword">int</span> _to=<span class="number">0</span>,<span class="keyword">int</span> _v=<span class="number">0</span>,<span class="keyword">int</span> _next=<span class="number">0</span>):from(_from),to(_to),v(_v),next(_next)&#123;&#125;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> edge_tot,last[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> vv)</span></span>&#123;edge[++edge_tot]=Edge(f,t,vv,last[f]),last[f]=edge_tot;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> id[x]&lt;id[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> father,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    fa[k][<span class="number">0</span>]=father,dep[k]=d,id[k]=++dfn,siz[k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[k];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to==father) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(edge[i].to,k,d+<span class="number">1</span>);</span><br><span class="line">        siz[k]+=siz[edge[i].to];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(dep[fa[x][i]]&gt;=dep[y]) x=fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getson</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(dep[fa[y][i]]&gt;dep[x]) y=fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sta[N],top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca;</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">1</span>]!=<span class="number">1</span>) sta[top++]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!top) <span class="keyword">break</span>;</span><br><span class="line">            lca=getlca(sta[top<span class="number">-1</span>],a[i]);</span><br><span class="line">            <span class="keyword">if</span>(lca==sta[top<span class="number">-1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                top--;</span><br><span class="line">                <span class="keyword">if</span>(id[sta[top<span class="number">-1</span>]]&gt;=id[lca])&#123;</span><br><span class="line">                    add_edge(sta[top<span class="number">-1</span>],sta[top],siz[getson(sta[top<span class="number">-1</span>],sta[top])]-siz[sta[top]]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    add_edge(lca,sta[top],siz[getson(lca,sta[top])]-siz[sta[top]]);</span><br><span class="line">                    sta[top++]=lca;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[top++]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        top--;</span><br><span class="line">        add_edge(sta[top<span class="number">-1</span>],sta[top],siz[getson(sta[top<span class="number">-1</span>],sta[top])]-siz[sta[top]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_dp1</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    c[++dfn]=k,w[k]=siz[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[k];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to==father) <span class="keyword">continue</span>;</span><br><span class="line">        w[k]-=siz[edge[i].to]+edge[i].v;</span><br><span class="line">        dfs_dp1(edge[i].to,k);</span><br><span class="line">        <span class="keyword">if</span>(d[k]&gt;d[edge[i].to]+dep[edge[i].to]-dep[k]) d[k]=d[edge[i].to]+dep[edge[i].to]-dep[k],f[k]=f[edge[i].to];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[k]==d[edge[i].to]+dep[edge[i].to]-dep[k]&amp;&amp;f[edge[i].to]&lt;f[k]) f[k]=f[edge[i].to];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_dp2</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=last[k];i;i=edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to==father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(d[edge[i].to]&gt;d[k]+dep[edge[i].to]-dep[k]) d[edge[i].to]=d[k]+dep[edge[i].to]-dep[k],f[edge[i].to]=f[k];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[edge[i].to]==d[k]+dep[edge[i].to]-dep[k]&amp;&amp;f[edge[i].to]&gt;f[k]) f[edge[i].to]=f[k];</span><br><span class="line">        dfs_dp2(edge[i].to,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1=edge[k].from,t2=edge[k].to,nxt;</span><br><span class="line">    <span class="keyword">if</span>(f[t1]==f[t2])&#123;ans[f[t1]]+=edge[k].v;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        nxt=fa[mid][i];</span><br><span class="line">        <span class="keyword">if</span>(id[nxt]&lt;id[t1]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(d[t1]+dep[nxt]-dep[t1]&gt;d[t2]+dep[t2]-dep[nxt]||(d[t1]+dep[nxt]-dep[t1]==d[t2]+dep[t2]-dep[nxt])&amp;&amp;f[t2]&lt;f[t1]) mid=nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[f[t1]]+=siz[getson(t1,mid)]-siz[mid];</span><br><span class="line">    ans[f[t2]]+=siz[mid]-siz[t2];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=dfn;i++) last[c[i]]=f[c[i]]=ans[c[i]]=w[c[i]]=<span class="number">0</span>,d[c[i]]=oo;</span><br><span class="line">    edge_tot=dfn=top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),b[i]=a[i],f[a[i]]=a[i],d[a[i]]=<span class="number">0</span>;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>,cmp);</span><br><span class="line">    build();</span><br><span class="line">    dfs_dp1(<span class="number">1</span>,<span class="number">0</span>);dfs_dp2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=dfn;i++) ans[f[c[i]]]+=w[c[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edge_tot;i++) solve(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[b[i]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t1,&amp;t2);</span><br><span class="line">        add_edge(t1,t2,<span class="number">0</span>);add_edge(t2,t1,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            fa[j][i]=fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="keyword">sizeof</span>(last));<span class="built_in">memset</span>(d,<span class="number">127</span>/<span class="number">2</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    edge_tot=dfn=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) query();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu1880」[NOI1995]石子合并</title>
      <link href="/2018/03/08/%E3%80%8Cluogu1880%E3%80%8D-NOI1995-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
      <url>/2018/03/08/%E3%80%8Cluogu1880%E3%80%8D-NOI1995-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>$N$堆石子排成一个环,现要将石子有次序地合并成一堆.每次只能选相邻的2堆合并成新的一堆，得分为新的一堆的石子数。</p><p>计算将N堆石子合并成1堆的最小得分和最大得分。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>四边形不等式优化的经典模型。</p><p>以最大值为例，转移方程为：</p><script type="math/tex; mode=display">f[i][j]=\max_{}(f[i][k]+f[k+1][j]+sum(i,j))</script><p>因为每堆石子数都是正的，所以代价函数$sum(i,j)$满足区间包含的单调性。</p><p>sum(i,j)+sum(i-1,j+1)=sum(i-1,j)+sum(i,j+1),即sum满足四边形不等式。</p><p>那么我们就可以用四边形不等式优化啦。</p><p>记$p[i][j]$为$f[i][j]$的决策点，那么p[i][j]\leq p[i][j+1]\leq p[i+1][j+1]。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,oo=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],f[N][N],p[N][N],ans1=oo,ans2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),a[i+n]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++) a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">127</span>/<span class="number">3</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++) f[i][i]=<span class="number">0</span>,p[i][i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j+i<span class="number">-1</span>&lt;=(n&lt;&lt;<span class="number">1</span>);j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=p[j][i+j<span class="number">-2</span>];k&lt;=p[j+<span class="number">1</span>][i+j<span class="number">-1</span>];k++)</span><br><span class="line">                <span class="keyword">if</span>(f[j][i+j<span class="number">-1</span>]&gt;f[j][k]+f[k+<span class="number">1</span>][i+j<span class="number">-1</span>]+a[i+j<span class="number">-1</span>]-a[j<span class="number">-1</span>]) f[j][i+j<span class="number">-1</span>]=f[j][k]+f[k+<span class="number">1</span>][i+j<span class="number">-1</span>]+a[i+j<span class="number">-1</span>]-a[j<span class="number">-1</span>],p[j][i+j<span class="number">-1</span>]=k;</span><br><span class="line">            <span class="keyword">if</span>(i==n) ans1=min(ans1,f[j][i+j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i+j<span class="number">-1</span>&lt;=(n&lt;&lt;<span class="number">1</span>);j++)&#123;</span><br><span class="line">            f[j][i+j<span class="number">-1</span>]=max(f[j][i+j<span class="number">-2</span>],f[j+<span class="number">1</span>][i+j<span class="number">-1</span>])+a[i+j<span class="number">-1</span>]-a[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i==n) ans2=max(ans2,f[j][i+j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ1070」[SCOI2007]修车</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ1070%E3%80%8D-SCOI2007-%E4%BF%AE%E8%BD%A6/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ1070%E3%80%8D-SCOI2007-%E4%BF%AE%E8%BD%A6/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>同一时刻有$N$位车主带着他们的爱车来到了汽车维修中心。维修中心共有$M$位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这$M$位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>求平均时间最小，也就是求总时间最小。</p><p>某个技术人员在修某一辆车时对总时间的贡献是 $time * 在排队的人数$。</p><p>所以可以想到把技术人员拆成$n$个点${m_{i1},m_{i2},……,m_{in}​}$，分别对应队伍中有1，2，……，n个人的情况。</p><p>对于每个顾客，向$m_{ij}$​连一条容量为1，花费为 $time * j$ 的边。</p><p>求这个二分图的最大权匹配即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000</span>,oo=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ss,tt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,flow,cap,cost;</span><br><span class="line">    Edge(<span class="keyword">int</span> _from=<span class="number">0</span>,<span class="keyword">int</span> _to=<span class="number">0</span>,<span class="keyword">int</span> _flow=<span class="number">0</span>,<span class="keyword">int</span> _cap=<span class="number">0</span>,<span class="keyword">int</span> _cost=<span class="number">0</span>):from(_from),to(_to),flow(_flow),cap(_cap),cost(_cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt;edge;</span><br><span class="line"><span class="keyword">int</span> edge_tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> c,<span class="keyword">int</span> cc)</span></span>&#123;</span><br><span class="line">    edge.push_back(Edge(f,t,<span class="number">0</span>,c,cc));</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    edge.push_back(Edge(t,f,<span class="number">0</span>,<span class="number">0</span>,-cc));</span><br><span class="line">    point[t].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[N],pre[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">127</span>/<span class="number">2</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(ss);</span><br><span class="line">    dis[ss]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class="line">            Edge&amp; e=edge[point[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&gt;e.flow&amp;&amp;dis[e.to]&gt;dis[x]+e.cost)&#123;</span><br><span class="line">                dis[e.to]=dis[x]+e.cost,pre[e.to]=point[x][i];</span><br><span class="line">                q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[tt]&lt;oo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincostmaxflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now,minf,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa())&#123;</span><br><span class="line">        minf=oo,now=tt;</span><br><span class="line">        <span class="keyword">while</span>(now!=ss)&#123;</span><br><span class="line">            minf=min(minf,edge[pre[now]].cap-edge[pre[now]].flow);</span><br><span class="line">            now=edge[pre[now]].from;</span><br><span class="line">        &#125;</span><br><span class="line">        now=tt,ans+=minf*dis[tt];</span><br><span class="line">        <span class="keyword">while</span>(now!=ss)&#123;</span><br><span class="line">            edge[pre[now]].flow+=minf,edge[pre[now]^<span class="number">1</span>].flow-=minf;</span><br><span class="line">            now=edge[pre[now]].from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    ss=n*m+n+<span class="number">1</span>,tt=ss+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t1);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++) add_edge(m*n+i,k*m+j,<span class="number">1</span>,t1*(k+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add_edge(ss,i+m*n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m*n;i++) add_edge(i,tt,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf"</span>,<span class="number">1.0</span>*mincostmaxflow()/n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu2714」四元组统计</title>
      <link href="/2018/03/08/%E3%80%8Cluogu2714%E3%80%8D%E5%9B%9B%E5%85%83%E7%BB%84%E7%BB%9F%E8%AE%A1/"/>
      <url>/2018/03/08/%E3%80%8Cluogu2714%E3%80%8D%E5%9B%9B%E5%85%83%E7%BB%84%E7%BB%9F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$n$个正整数$a_i$，统计有多少个四元组满足$gcd(a_i,a_j,a_k,a_l)$=1。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>令$f[i]$为$gcd(a_i,a_j,a_k,a_l)$为$i$的倍数的四元组个数，$g[i]$为$gcd(a_i,a_j,a_k,a_l)$为$i$的四元组个数。</p><p>$f[i]$比较好求，令$X$为$a_i$中i的倍数的个数，则:</p><script type="math/tex; mode=display">f[i]=C_{X}^{4}</script><p>接下来用$f[i]$求出$g[i]$:</p><script type="math/tex; mode=display">f[i]=\sum_{i|j}^{} {g[j]}</script><p>莫比乌斯反演一下</p><script type="math/tex; mode=display">g[i]=\sum_{i|j}^{} {\mu[\frac{j}{i}]} f[j]</script><p>完成！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>,maxn=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],u[N],p[N],totp;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="keyword">bool</span> isp[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(ll k)</span></span>&#123;<span class="keyword">return</span> k*(k<span class="number">-1</span>)*(k<span class="number">-2</span>)*(k<span class="number">-3</span>)/<span class="number">4</span>/<span class="number">3</span>/<span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t),a[t]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=maxn;j+=i) f[i]+=a[j];</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;<span class="number">3</span>) f[i]=calc(f[i]);</span><br><span class="line">        <span class="keyword">else</span> f[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++) ans+=f[i]*u[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isp[<span class="number">1</span>]=<span class="number">1</span>,u[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isp[i]) p[++totp]=i,u[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=totp&amp;&amp;p[j]*i&lt;=maxn;j++)&#123;</span><br><span class="line">            isp[p[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%p[j])) <span class="keyword">break</span>;</span><br><span class="line">            u[p[j]*i]=-u[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu1251」餐巾计划问题</title>
      <link href="/2018/03/08/%E3%80%8Cluogu1251%E3%80%8D%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/08/%E3%80%8Cluogu1251%E3%80%8D%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个餐厅在相继的$N$天里,每天需用的餐巾数不尽相同。假设第$i$天需要$r_i$块餐巾$(i=1,2,…,N)$。餐厅可以购买新的餐巾,每块餐巾的费用为$p$分;或者把旧餐巾送到快洗部,洗一块需$m$天,其费用为$f$分;或者送到慢洗部,洗一块需$n$天$(n&gt;m)$,其费用为$s$分$(s&lt;f)$。</p><p>每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。</p><p>试设计一个算法为餐厅合理地安排好$N$天中餐巾使用计划,使总的花费最小。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>拆点，把点i拆成$X_i$和$Y_i$。</p><p>每个$X_i$向汇点$t$连一条容量为$r_i$，费用为0的边，表示每天要满足的要求。(这里涉及到一个贪心即每天恰好提供$r_i$块餐巾时总花费最小，因为我们总可以把餐巾留到下一天而不用支付额外的费用，所以这样做不会使方案更劣)</p><p>源点$s$向每个$Y_i$连一条容量为$r_i$，费用为0的边，表示向网络中补充这一天使用后的餐巾。</p><p>源点$s$向每个$X_i$连一条容量为正无穷，费用为$p$的边，表示购买新的餐巾。</p><p>每个$Y_i$向$Y_{i+1}$连一条容量为正无穷，费用为0的边，表示把脏餐巾留到下一天。</p><p>每个$Y_i$向$X_{i+m}$连一条容量为正无穷，费用为$f$的边，表示送到快洗部。</p><p>每个$Y_i$向$X_{i+n}$连一条容量为正无穷，费用为$s$的边，表示送到慢洗部。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> ll oo=<span class="number">3e18</span>;</span><br><span class="line"><span class="keyword">int</span> tot,n,m,f,s,p,super_s,<span class="keyword">super_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to;</span><br><span class="line">    ll flow,cap,cost;</span><br><span class="line">    Edge(<span class="keyword">int</span> _from=<span class="number">0</span>,<span class="keyword">int</span> _to=<span class="number">0</span>,ll _flow=<span class="number">0</span>,ll _cap=<span class="number">0</span>,ll _cost=<span class="number">0</span>):from(_from),to(_to),flow(_flow),cap(_cap),cost(_cost)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Edge edge[<span class="number">40010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[N];</span><br><span class="line"><span class="keyword">int</span> edge_tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,ll c,ll cc)</span></span>&#123;</span><br><span class="line">    edge[edge_tot]=Edge(f,t,<span class="number">0</span>,c,cc);</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    edge[edge_tot]=Edge(t,f,<span class="number">0</span>,<span class="number">0</span>,-cc);</span><br><span class="line">    point[t].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">127</span>/<span class="number">2</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(super_s);</span><br><span class="line">    dis[super_s]=<span class="number">0</span>,inq[super_s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front();q.pop();</span><br><span class="line">        inq[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class="line">            Edge&amp; e=edge[point[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&lt;=e.flow) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[e.to]&gt;dis[x]+e.cost)&#123;</span><br><span class="line">                dis[e.to]=dis[x]+e.cost,pre[e.to]=point[x][i];</span><br><span class="line">                <span class="keyword">if</span>(!inq[e.to])&#123;q.push(e.to);inq[e.to]=<span class="number">1</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[<span class="keyword">super_t</span>]&lt;oo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mincostflow</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    ll minf,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa())&#123;</span><br><span class="line">        minf=oo,now=<span class="keyword">super_t</span>;</span><br><span class="line">        <span class="keyword">while</span>(now!=super_s) minf=min(minf,edge[pre[now]].cap-edge[pre[now]].flow),now=edge[pre[now]].from;</span><br><span class="line">        now=<span class="keyword">super_t</span>,ans+=<span class="number">1L</span>L*minf*dis[<span class="keyword">super_t</span>];</span><br><span class="line">        <span class="keyword">while</span>(now!=super_s) edge[pre[now]].flow+=minf,edge[pre[now]^<span class="number">1</span>].flow-=minf,now=edge[pre[now]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tot);</span><br><span class="line">    super_s=tot+tot+<span class="number">1</span>,<span class="keyword">super_t</span>=tot+tot+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t1);</span><br><span class="line">        add_edge(super_s,i,t1,<span class="number">0</span>);</span><br><span class="line">        add_edge(i+tot,<span class="keyword">super_t</span>,t1,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;tot) add_edge(i+tot,i+tot+<span class="number">1</span>,oo,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;p,&amp;m,&amp;f,&amp;n,&amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot-m;i++) add_edge(i,i+m+tot,oo,f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot-n;i++) add_edge(i,i+n+tot,oo,s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) add_edge(super_s,i+tot,oo,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,mincostflow());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu2764」最小路径覆盖问题</title>
      <link href="/2018/03/08/%E3%80%8Cluogu2764%E3%80%8D%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/08/%E3%80%8Cluogu2764%E3%80%8D%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求一个DAG的最小路径覆盖，输出方案。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>把原图中的每个点都拆成两个点，然后对于原图中的每条边$(u,v)$，连接$(u,v’)$。</p><p>求这个二分图的最大匹配，最小路径覆盖数就是原节点数-最大匹配数。</p><p>因为在这个二分图中，每增加一个匹配相当与把两个路径合成一条，答案数减一。</p><p>输出方案只要沿着匹配边走一遍就可以啦。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">160</span>,M=<span class="number">6010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,link[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> used[N&lt;&lt;<span class="number">1</span>],start[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)<span class="keyword">if</span>(!used[point[k][i]])&#123;</span><br><span class="line">        used[point[k][i]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!link[point[k][i]]||find(link[point[k][i]]))&#123;</span><br><span class="line">            link[point[k][i]]=k;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t1,&amp;t2);</span><br><span class="line">        point[t2].push_back(t1+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="keyword">if</span>(find(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=n-ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i]=<span class="number">1</span>;</span><br><span class="line">        t1=link[i+n];</span><br><span class="line">        <span class="keyword">while</span>(t1)&#123;</span><br><span class="line">            vis[t1]=start[t1]=<span class="number">1</span>;</span><br><span class="line">            t1=link[t1+n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!start[i])&#123;</span><br><span class="line">        t1=i;</span><br><span class="line">        <span class="keyword">while</span>(t1)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,t1);</span><br><span class="line">            t1=link[t1+n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu2763」试题库问题</title>
      <link href="/2018/03/08/%E3%80%8Cluogu2763%E3%80%8D%E8%AF%95%E9%A2%98%E5%BA%93%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/08/%E3%80%8Cluogu2763%E3%80%8D%E8%AF%95%E9%A2%98%E5%BA%93%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>假设一个试题库中有$n$道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取$m$道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>考虑网络流，源点连试题，试题连各自的类型，类型按要求连汇点，跑最大流即可。</p><p>具体见代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1050</span>,K=<span class="number">30</span>,oo=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> k,n,ss,tt,cnt[K];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,flow,cap;</span><br><span class="line">    Edge(<span class="keyword">int</span> _from=<span class="number">0</span>,<span class="keyword">int</span> _to=<span class="number">0</span>,<span class="keyword">int</span> _flow=<span class="number">0</span>,<span class="keyword">int</span> _cap=<span class="number">0</span>):from(_from),to(_to),flow(_flow),cap(_cap)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res[K];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edge;</span><br><span class="line"><span class="keyword">int</span> edge_tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    edge.push_back(Edge(f,t,<span class="number">0</span>,c));</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    edge.push_back(Edge(t,f,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    point[t].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> level[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">0</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(ss);</span><br><span class="line">    level[ss]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class="line">            Edge&amp; e=edge[point[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&gt;e.flow&amp;&amp;!level[e.to])&#123;</span><br><span class="line">                level[e.to]=level[x]+<span class="number">1</span>;</span><br><span class="line">                q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[tt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> aa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==tt||!aa) <span class="keyword">return</span> aa;</span><br><span class="line">    <span class="keyword">int</span> temp,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(e.cap&gt;e.flow&amp;&amp;level[e.to]==level[k]+<span class="number">1</span>&amp;&amp;(temp=dfs(e.to,min(aa,e.cap-e.flow))))&#123;</span><br><span class="line">            ans+=temp,aa-=temp;</span><br><span class="line">            e.flow+=temp,edge[point[k][i]^<span class="number">1</span>].flow-=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!aa) <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans+=dfs(ss,oo);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1,t2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;n);</span><br><span class="line">    ss=k+n+<span class="number">1</span>,tt=ss+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cnt[i]);</span><br><span class="line">        add_edge(n+i,tt,cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add_edge(ss,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t1;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t2);</span><br><span class="line">            add_edge(i,t2+n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dinic();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[(i<span class="number">-1</span>)&lt;&lt;<span class="number">1</span>].cap&gt;edge[(i<span class="number">-1</span>)&lt;&lt;<span class="number">1</span>].flow)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No Solution!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;point[i].size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[point[i][j]].flow==<span class="number">1</span>)&#123;</span><br><span class="line">                res[edge[point[i][j]].to-n].push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:"</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;res[i].size();j++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,res[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu2766」最长不下降子序列问题</title>
      <link href="/2018/03/08/%E3%80%8Cluogu2766%E3%80%8D%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/08/%E3%80%8Cluogu2766%E3%80%8D%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定正整数序列$x_1,…,x_n$ 。</p><p>(1) 计算其最长不下降子序列的长度$s$。</p><p>(2) 计算从给定的序列中最多可取出多少个长度为$s$的不下降子序列。</p><p>(3) 如果允许在取出的序列中多次使用$x_1$和$x_n$，则从给定序列中最多可取出多少个长度为$s$的不下降子序列。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>第一问用动态规划解决,记答案为$ans_1$,保留$f[i]$供下面建模用。</p><p>第二问可以看出是一个求路径覆盖数的问题，要求路径长度为$ans_1$。</p><p>建模：<br>(1) 把每个点拆成$i$和$i’$,$i$向$i’$连一条边。<br>(2) 对于所有满足$i&lt;j$且$a[j]\leq a[i]$且$f[i]==f[j]-1$的点，$i’$向$j$连一条边。<br>(3) 源点$s$向$f[i]==1$的点$i$连一条边，$f[i]==ans_1$的点$i’$向汇点$t$连一条边。</p><p>这样从s到t的任何一条路径都是是按照$f[i]$的顺序走的，求出最大流也就是第二问的答案。</p><p>把图中$(s,1)$、$(n’,t)$、$(1,1’)$、$(n,n’)$这4条边的容量改成正无穷,即可解决第三问。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">251000</span>,oo=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],f[N],ss,tt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,flow,cap;</span><br><span class="line">    Edge(<span class="keyword">int</span> _from=<span class="number">0</span>,<span class="keyword">int</span> _to=<span class="number">0</span>,<span class="keyword">int</span> _flow=<span class="number">0</span>,<span class="keyword">int</span> _cap=<span class="number">0</span>):from(_from),to(_to),flow(_flow),cap(_cap)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Edge edge[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> edge_tot,spe[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    edge[edge_tot]=Edge(f,t,<span class="number">0</span>,c);</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    edge[edge_tot]=Edge(t,f,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    point[t].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> level[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">0</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(ss);</span><br><span class="line">    level[ss]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class="line">            Edge&amp; e=edge[point[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&gt;e.flow&amp;&amp;!level[e.to])&#123;</span><br><span class="line">                level[e.to]=level[x]+<span class="number">1</span>;</span><br><span class="line">                q.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[tt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> aa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==tt||!aa) <span class="keyword">return</span> aa;</span><br><span class="line">    <span class="keyword">int</span> temp,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(e.cap&gt;e.flow&amp;&amp;level[e.to]==level[k]+<span class="number">1</span>&amp;&amp;(temp=dfs(e.to,min(aa,e.cap-e.flow))))&#123;</span><br><span class="line">            ans+=temp,aa-=temp;</span><br><span class="line">            e.flow+=temp,edge[point[k][i]^<span class="number">1</span>].flow-=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!aa) <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans+=dfs(ss,oo);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>,ans3=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    ss=(n&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,tt=ss+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    a[<span class="number">0</span>]=-oo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) <span class="keyword">if</span>(a[i]&gt;=a[j]) f[i]=max(f[j]+<span class="number">1</span>,f[i]);</span><br><span class="line">        ans1=max(ans1,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>||i==n) spe[++spe[<span class="number">0</span>]]=edge_tot;</span><br><span class="line">        add_edge(i,i+n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(f[i]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) spe[++spe[<span class="number">0</span>]]=edge_tot;</span><br><span class="line">add_edge(ss,i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(f[i]==ans1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==n) spe[++spe[<span class="number">0</span>]]=edge_tot;</span><br><span class="line">add_edge(i+n,tt,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(a[j]&gt;=a[i]&amp;&amp;f[i]==f[j]<span class="number">-1</span>)</span><br><span class="line">            add_edge(i+n,j,<span class="number">1</span>);</span><br><span class="line">    ans2=dinic();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge_tot;i++) edge[i].flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=spe[<span class="number">0</span>];i++) edge[spe[i]].cap=oo;</span><br><span class="line">    ans3=dinic();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ3160」万径人踪灭</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ3160%E3%80%8D%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ3160%E3%80%8D%E4%B8%87%E5%BE%84%E4%BA%BA%E8%B8%AA%E7%81%AD/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求一个只含a,b的字符串中位置和字符都关于某条对称轴对称且不连续的子序列个数，答案对1000000007取模。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>先求出所有满足第一个条件的子序列个数，再减去回文子串个数。</p><p>回文子串个数可以用manacher求出，关键是第一步。</p><p>我们先考虑确定一个对称轴，那么只要知道关于这条对称轴对称的字符对个数,记为$F_i$，那么对答案的贡献就是$2^{F_i}-1$。</p><p>写出$F_i$的表达式:</p><script type="math/tex; mode=display">F_i=\sum_{j}^{} {s[i-j]==s[i+j]}</script><p>我们发现这是个卷积形式，把字符串中a的位置赋为1，b的位置赋为0，就可以求出a的贡献，同理可求出b的贡献。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">150010</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> db PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    db real,image;</span><br><span class="line">    Complex(db _real=<span class="number">0</span>,db _image=<span class="number">0</span>):real(_real),image(_image)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(Complex k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Complex(real+k.real,image+k.image);&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>-(Complex k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Complex(real-k.real,image-k.image);&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>*(Complex k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Complex(real*k.real-image*k.image,real*k.image+image*k.real);&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>/(<span class="keyword">int</span> k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> Complex(real/k,image/k);&#125;</span><br><span class="line">&#125;a[N&lt;&lt;<span class="number">1</span>],b[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,l,maxp,f[N&lt;&lt;<span class="number">1</span>],rev[N&lt;&lt;<span class="number">1</span>],pow2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex* x,<span class="keyword">int</span> f)</span></span>&#123;<span class="comment">//f=1时为fft，f=-1时为ifft</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(rev[i]&gt;i) swap(x[i],x[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;n;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        Complex wn(cos(PI/len),f*sin(PI/len));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">0</span>;now&lt;n<span class="number">-1</span>;now+=(len&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++,w=w*wn)&#123;</span><br><span class="line">                Complex t1=x[now+i],t2=w*x[now+len+i];</span><br><span class="line">                x[now+i]=t1+t2,x[now+len+i]=t1-t2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) x[i]=x[i]/n;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxr,pos,r[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">/** TLE代码</span></span><br><span class="line"><span class="comment">int manacher()&#123;</span></span><br><span class="line"><span class="comment">  int ans=0;</span></span><br><span class="line"><span class="comment">  s2[l2++]='#';</span></span><br><span class="line"><span class="comment">  for(int i=0;i&lt;l;i++) s2[l2++]=s[i],s2[l2++]='#';</span></span><br><span class="line"><span class="comment">  for(int i=0;i&lt;l2;i++)&#123;</span></span><br><span class="line"><span class="comment">      r[i]=(maxr&gt;=i)?min(maxr-i+1,r[(pos&lt;&lt;1)-i]):1;</span></span><br><span class="line"><span class="comment">      while(i-r[i]&gt;=0&amp;&amp;i+r[i]&lt;l2&amp;&amp;s2[i-r[i]]==s2[i+r[i]]) r[i]++; </span></span><br><span class="line"><span class="comment">      if(r[i]&gt;maxr) maxr=r[i],pos=i;</span></span><br><span class="line"><span class="comment">      ans=ans+(r[i]&gt;&gt;1);</span></span><br><span class="line"><span class="comment">      if(ans&gt;mod) ans-=mod;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return ans;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    s[l+<span class="number">1</span>]=<span class="string">'#'</span>,s[<span class="number">0</span>]=<span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxr&gt;i) r[i]=min(maxr-i+<span class="number">1</span>,r[pos*<span class="number">2</span>-i]);</span><br><span class="line">        <span class="keyword">else</span> r[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i+r[i]]==s[i-r[i]]) r[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+r[i]<span class="number">-1</span>&gt;maxr) maxr=i+r[i]<span class="number">-1</span>,pos=i;</span><br><span class="line">        ans=(ans+r[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    maxr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxr&gt;i) r[i]=min(maxr-i,r[pos*<span class="number">2</span>-i]);</span><br><span class="line">        <span class="keyword">else</span> r[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i+r[i]+<span class="number">1</span>]==s[i-r[i]]) r[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+r[i]&gt;maxr) maxr=i+r[i],pos=i;</span><br><span class="line">        ans=(ans+r[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">    l=<span class="built_in">strlen</span>(s+<span class="number">1</span>),n=l<span class="number">-1</span>;</span><br><span class="line">    m=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>) maxp++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(maxp<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++) a[i<span class="number">-1</span>].real=(s[i]==<span class="string">'a'</span>),b[i<span class="number">-1</span>].real=(s[i]==<span class="string">'b'</span>);</span><br><span class="line">    fft(a,<span class="number">1</span>);fft(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*a[i],b[i]=b[i]*b[i];</span><br><span class="line">    fft(a,<span class="number">-1</span>);fft(b,<span class="number">-1</span>);</span><br><span class="line">    pow2[<span class="number">0</span>]=<span class="number">1</span>,f[<span class="number">0</span>]=<span class="keyword">int</span>(a[<span class="number">0</span>].real+b[<span class="number">0</span>].real+<span class="number">1.1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        pow2[i]=pow2[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>,f[i]=<span class="keyword">int</span>(a[i].real+b[i].real+<span class="number">1.1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pow2[i]&gt;=mod) pow2[i]-=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans=(ans+pow2[f[i]]<span class="number">-1</span>)%mod;</span><br><span class="line">    <span class="keyword">int</span> temp=manacher();</span><br><span class="line">    ans-=temp;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;<span class="number">0</span>) ans+=mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「luogu2765」魔术球问题</title>
      <link href="/2018/03/08/%E3%80%8Cluogu2765%E3%80%8D%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/08/%E3%80%8Cluogu2765%E3%80%8D%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$n$根柱子，现要按下述规则在这$n$根柱子中依次放入编号为1，2，3，…的球。</p><p>（1）每次只能在某根柱子的最上面放球。</p><p>（2）在同一根柱子中，任何2个相邻球的编号之和为完全平方数。</p><p>求在$n$根柱子上最多能放多少个球。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>看完题目后很自然的建出这样一个图：对于满足要求的两个点$u$、$v$，连一条边$(u，v)$。</p><p>那么一根柱子就相当与这个图中的一条路径，于是问题就转化成求一个DAG的最小路径覆盖。</p><p>最小路径覆盖的求法见 <a href="http://blog.mycup.cc/2018/03/08/%E3%80%8Cluogu2764%E3%80%8D%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">这里</a></p><p>因为图的形态与要放入的小球有关，所以我们顺序枚举小球个数$ans$，一旦不满足条件就停止，此时$ans-1$就是答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">60</span>,M=<span class="number">4010</span>,oo=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,ss=<span class="number">4000</span>,tt=<span class="number">4001</span>,f[M];</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,flow,cap;</span><br><span class="line">    Edge(<span class="keyword">int</span> _from=<span class="number">0</span>,<span class="keyword">int</span> _to=<span class="number">0</span>,<span class="keyword">int</span> _flow=<span class="number">0</span>,<span class="keyword">int</span> _cap=<span class="number">0</span>):from(_from),to(_to),flow(_flow),cap(_cap)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> edge_tot;</span><br><span class="line">Edge edge[<span class="number">100500</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;point[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    edge[edge_tot]=Edge(f,t,<span class="number">0</span>,c);</span><br><span class="line">    point[f].push_back(edge_tot++);</span><br><span class="line">    edge[edge_tot]=Edge(t,f,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    point[t].push_back(edge_tot++);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> level[M];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">0</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(ss);</span><br><span class="line">    level[ss]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class="line">            Edge e=edge[point[x][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.cap&gt;e.flow&amp;&amp;!level[e.to])&#123;</span><br><span class="line">                <span class="keyword">int</span> nxt=edge[point[x][i]].to;</span><br><span class="line">                level[nxt]=level[x]+<span class="number">1</span>;</span><br><span class="line">                q.push(nxt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level[tt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==tt||!a) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> temp,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class="line">        Edge&amp; e=edge[point[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(e.cap&gt;e.flow&amp;&amp;level[e.to]==level[k]+<span class="number">1</span>&amp;&amp;(temp=dfs(e.to,min(a,e.cap-e.flow))))&#123;</span><br><span class="line">            ans+=temp,a-=temp;</span><br><span class="line">            e.flow+=temp,edge[point[k][i]^<span class="number">1</span>].flow-=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!a) <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())</span><br><span class="line">        ans+=dfs(ss,oo);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> ans,t1,t2;</span><br><span class="line">    <span class="keyword">for</span>(ans=<span class="number">1</span>;<span class="number">1</span>;ans++)&#123;</span><br><span class="line">        add_edge(ss,(ans&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>,<span class="number">1</span>);add_edge((ans&lt;&lt;<span class="number">1</span>),tt,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ans;i++)&#123;</span><br><span class="line">            t1=i+ans,t2=<span class="built_in">sqrt</span>(t1);</span><br><span class="line">            <span class="keyword">if</span>(t2*t2==t1) add_edge((ans&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>,(i&lt;&lt;<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        t1=dinic();</span><br><span class="line">        <span class="keyword">if</span>(ans-t1&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge_tot;i++) edge[i].flow=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;point[(i&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>].size();j++)</span><br><span class="line">            <span class="keyword">if</span>(edge[point[(i&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>][j]].flow&gt;<span class="number">0</span>)&#123;f[(edge[point[(i&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>][j]].to)&gt;&gt;<span class="number">1</span>]=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">        vis[i]=<span class="number">1</span>,t1=f[i];</span><br><span class="line">        <span class="keyword">while</span>(t1)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,t1);</span><br><span class="line">            vis[t1]=<span class="number">1</span>,t1=f[t1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>「BZOJ3527」[Zjoi2014]力</title>
      <link href="/2018/03/08/%E3%80%8CBZOJ3527%E3%80%8D-Zjoi2014-%E5%8A%9B/"/>
      <url>/2018/03/08/%E3%80%8CBZOJ3527%E3%80%8D-Zjoi2014-%E5%8A%9B/</url>
      <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出$n$个数 $ q_i $ ，给出$F_j$的定义如下：</p><script type="math/tex; mode=display">F_j = \sum_{i<j}\frac{q_i q_j}{(i-j)^2 }-\sum_{i>j}\frac{q_i q_j}{(i-j)^2 }</script><p>令$E_i=\frac{F_i}{q_i}$，求$E_i$。<br><a id="more"></a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>化简一下：</p><script type="math/tex; mode=display">E_j = \sum_{i<j}\frac{q_i}{(i-j)^2 }-\sum_{i>j}\frac{q_i}{(i-j)^2 }</script><p>我们发现这是两个卷积形式，fft即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">400000</span>;</span><br><span class="line"><span class="keyword">const</span> db PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    db real,image;</span><br><span class="line">    Complex(db _real=<span class="number">0</span>,db _image=<span class="number">0</span>):real(_real),image(_image)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(Complex k)&#123;<span class="keyword">return</span> Complex(real+k.real,image+k.image);&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>-(Complex k)&#123;<span class="keyword">return</span> Complex(real-k.real,image-k.image);&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>*(Complex k)&#123;<span class="keyword">return</span> Complex(real*k.real-image*k.image,real*k.image+image*k.real);&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>/(<span class="keyword">int</span> k)&#123;<span class="keyword">return</span> Complex(real/k,image/k);&#125;</span><br><span class="line">&#125;a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">int</span> on,n,m,maxp,rev[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex* x,<span class="keyword">int</span> iff)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(rev[i]&gt;i) swap(x[i],x[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        Complex wn(cos(2*PI/len),iff*sin(2*PI/len));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">0</span>;now&lt;n<span class="number">-1</span>;now+=len)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(len&gt;&gt;<span class="number">1</span>);i++,w=w*wn)&#123;</span><br><span class="line">                Complex t1=x[now+i],t2=w*x[now+(len&gt;&gt;<span class="number">1</span>)+i];</span><br><span class="line">                x[now+i]=t1+t2,x[now+(len&gt;&gt;<span class="number">1</span>)+i]=t1-t2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iff==<span class="number">-1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) x[i]=x[i]/n;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    db ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;on),on--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=on;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i) c[i].real=<span class="number">1.0</span>/i/i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i].real),b[on-i].real=a[i].real;</span><br><span class="line">    &#125;</span><br><span class="line">    m=on&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>) maxp++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|(i&amp;<span class="number">1</span>)&lt;&lt;(maxp<span class="number">-1</span>);</span><br><span class="line">    fft(a,<span class="number">1</span>);fft(b,<span class="number">1</span>);fft(c,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*c[i],b[i]=b[i]*c[i];</span><br><span class="line">    fft(a,<span class="number">-1</span>);fft(b,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=on;i++)&#123;</span><br><span class="line">        ans=a[i].real-b[on-i].real;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
  
  
</search>
