{"title":"「luogu2765」魔术球问题","date":"2018-03-08T05:12:11.000Z","excerpt":"","slug":"「luogu2765」魔术球问题","updated":"2018-07-14T14:31:56.025Z","content":"<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>有$n$根柱子，现要按下述规则在这$n$根柱子中依次放入编号为1，2，3，…的球。</p>\n<p>（1）每次只能在某根柱子的最上面放球。</p>\n<p>（2）在同一根柱子中，任何2个相邻球的编号之和为完全平方数。</p>\n<p>求在$n$根柱子上最多能放多少个球。</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>看完题目后很自然的建出这样一个图：对于满足要求的两个点$u$、$v$，连一条边$(u，v)$。</p>\n<p>那么一根柱子就相当与这个图中的一条路径，于是问题就转化成求一个DAG的最小路径覆盖。</p>\n<p>最小路径覆盖的求法见 <a href=\"http://blog.mycup.cc/2018/03/08/%E3%80%8Cluogu2764%E3%80%8D%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>因为图的形态与要放入的小球有关，所以我们顺序枚举小球个数$ans$，一旦不满足条件就停止，此时$ans-1$就是答案。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">60</span>,M=<span class=\"number\">4010</span>,oo=<span class=\"number\">2e9</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,ss=<span class=\"number\">4000</span>,tt=<span class=\"number\">4001</span>,f[M];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[M];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to,flow,cap;</span><br><span class=\"line\">    Edge(<span class=\"keyword\">int</span> _from=<span class=\"number\">0</span>,<span class=\"keyword\">int</span> _to=<span class=\"number\">0</span>,<span class=\"keyword\">int</span> _flow=<span class=\"number\">0</span>,<span class=\"keyword\">int</span> _cap=<span class=\"number\">0</span>):from(_from),to(_to),flow(_flow),cap(_cap)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> edge_tot;</span><br><span class=\"line\">Edge edge[<span class=\"number\">100500</span>];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;point[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> f,<span class=\"keyword\">int</span> t,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    edge[edge_tot]=Edge(f,t,<span class=\"number\">0</span>,c);</span><br><span class=\"line\">    point[f].push_back(edge_tot++);</span><br><span class=\"line\">    edge[edge_tot]=Edge(t,f,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    point[t].push_back(edge_tot++);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> level[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(level,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(level));</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt;q;</span><br><span class=\"line\">    q.push(ss);</span><br><span class=\"line\">    level[ss]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        x=q.front();q.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class=\"line\">            Edge e=edge[point[x][i]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(e.cap&gt;e.flow&amp;&amp;!level[e.to])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nxt=edge[point[x][i]].to;</span><br><span class=\"line\">                level[nxt]=level[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                q.push(nxt);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> level[tt];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> k,<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k==tt||!a) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;point[k].size();i++)&#123;</span><br><span class=\"line\">        Edge&amp; e=edge[point[k][i]];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e.cap&gt;e.flow&amp;&amp;level[e.to]==level[k]+<span class=\"number\">1</span>&amp;&amp;(temp=dfs(e.to,min(a,e.cap-e.flow))))&#123;</span><br><span class=\"line\">            ans+=temp,a-=temp;</span><br><span class=\"line\">            e.flow+=temp,edge[point[k][i]^<span class=\"number\">1</span>].flow-=temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!a) <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dinic</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(bfs())</span><br><span class=\"line\">        ans+=dfs(ss,oo);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans,t1,t2;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ans=<span class=\"number\">1</span>;<span class=\"number\">1</span>;ans++)&#123;</span><br><span class=\"line\">        add_edge(ss,(ans&lt;&lt;<span class=\"number\">1</span>)<span class=\"number\">-1</span>,<span class=\"number\">1</span>);add_edge((ans&lt;&lt;<span class=\"number\">1</span>),tt,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;ans;i++)&#123;</span><br><span class=\"line\">            t1=i+ans,t2=<span class=\"built_in\">sqrt</span>(t1);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t2*t2==t1) add_edge((ans&lt;&lt;<span class=\"number\">1</span>)<span class=\"number\">-1</span>,(i&lt;&lt;<span class=\"number\">1</span>),<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t1=dinic();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans-t1&gt;n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;edge_tot;i++) edge[i].flow=<span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans--;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=ans;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;point[(i&lt;&lt;<span class=\"number\">1</span>)<span class=\"number\">-1</span>].size();j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edge[point[(i&lt;&lt;<span class=\"number\">1</span>)<span class=\"number\">-1</span>][j]].flow&gt;<span class=\"number\">0</span>)&#123;f[(edge[point[(i&lt;&lt;<span class=\"number\">1</span>)<span class=\"number\">-1</span>][j]].to)&gt;&gt;<span class=\"number\">1</span>]=i;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=ans;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,i);</span><br><span class=\"line\">        vis[i]=<span class=\"number\">1</span>,t1=f[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(t1)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,t1);</span><br><span class=\"line\">            vis[t1]=<span class=\"number\">1</span>,t1=f[t1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"「BZOJ3160」万径人踪灭","slug":"「BZOJ3160」万径人踪灭"},"next":{"title":"「BZOJ3527」[Zjoi2014]力","slug":"「BZOJ3527」-Zjoi2014-力"},"link":"/2018/03/08","toc":[{"title":"题目大意","id":"题目大意","index":"1"},{"title":"解析","id":"解析","index":"2"},{"title":"代码","id":"代码","index":"3"}]}