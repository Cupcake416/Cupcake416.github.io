{"title":"「luogu1251」餐巾计划问题","date":"2018-03-08T05:17:30.000Z","excerpt":"","slug":"「luogu1251」餐巾计划问题","updated":"2018-07-15T12:11:28.017Z","content":"<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>一个餐厅在相继的$N$天里,每天需用的餐巾数不尽相同。假设第$i$天需要$r_i$块餐巾$(i=1,2,…,N)$。餐厅可以购买新的餐巾,每块餐巾的费用为$p$分;或者把旧餐巾送到快洗部,洗一块需$m$天,其费用为$f$分;或者送到慢洗部,洗一块需$n$天$(n&gt;m)$,其费用为$s$分$(s&lt;f)$。</p>\n<p>每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。</p>\n<p>试设计一个算法为餐厅合理地安排好$N$天中餐巾使用计划,使总的花费最小。</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>拆点，把点i拆成$X_i$和$Y_i$。</p>\n<p>每个$X_i$向汇点$t$连一条容量为$r_i$，费用为0的边，表示每天要满足的要求。(这里涉及到一个贪心即每天恰好提供$r_i$块餐巾时总花费最小，因为我们总可以把餐巾留到下一天而不用支付额外的费用，所以这样做不会使方案更劣)</p>\n<p>源点$s$向每个$Y_i$连一条容量为$r_i$，费用为0的边，表示向网络中补充这一天使用后的餐巾。</p>\n<p>源点$s$向每个$X_i$连一条容量为正无穷，费用为$p$的边，表示购买新的餐巾。</p>\n<p>每个$Y_i$向$Y_{i+1}$连一条容量为正无穷，费用为0的边，表示把脏餐巾留到下一天。</p>\n<p>每个$Y_i$向$X_{i+m}$连一条容量为正无穷，费用为$f$的边，表示送到快洗部。</p>\n<p>每个$Y_i$向$X_{i+n}$连一条容量为正无穷，费用为$s$的边，表示送到慢洗部。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N=<span class=\"number\">4010</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ll oo=<span class=\"number\">3e18</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> tot,n,m,f,s,p,super_s,<span class=\"keyword\">super_t</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    ll flow,cap,cost;</span><br><span class=\"line\">    Edge(<span class=\"keyword\">int</span> _from=<span class=\"number\">0</span>,<span class=\"keyword\">int</span> _to=<span class=\"number\">0</span>,ll _flow=<span class=\"number\">0</span>,ll _cap=<span class=\"number\">0</span>,ll _cost=<span class=\"number\">0</span>):from(_from),to(_to),flow(_flow),cap(_cap),cost(_cost)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Edge edge[<span class=\"number\">40010</span>];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;point[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> edge_tot;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"keyword\">int</span> f,<span class=\"keyword\">int</span> t,ll c,ll cc)</span></span>&#123;</span><br><span class=\"line\">    edge[edge_tot]=Edge(f,t,<span class=\"number\">0</span>,c,cc);</span><br><span class=\"line\">    point[f].push_back(edge_tot++);</span><br><span class=\"line\">    edge[edge_tot]=Edge(t,f,<span class=\"number\">0</span>,<span class=\"number\">0</span>,-cc);</span><br><span class=\"line\">    point[t].push_back(edge_tot++);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ll dis[N];</span><br><span class=\"line\"><span class=\"keyword\">int</span> pre[N];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> inq[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">127</span>/<span class=\"number\">2</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt;q;</span><br><span class=\"line\">    q.push(super_s);</span><br><span class=\"line\">    dis[super_s]=<span class=\"number\">0</span>,inq[super_s]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        x=q.front();q.pop();</span><br><span class=\"line\">        inq[x]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;point[x].size();i++)&#123;</span><br><span class=\"line\">            Edge&amp; e=edge[point[x][i]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(e.cap&lt;=e.flow) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[e.to]&gt;dis[x]+e.cost)&#123;</span><br><span class=\"line\">                dis[e.to]=dis[x]+e.cost,pre[e.to]=point[x][i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!inq[e.to])&#123;q.push(e.to);inq[e.to]=<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[<span class=\"keyword\">super_t</span>]&lt;oo;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mincostflow</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now;</span><br><span class=\"line\">    ll minf,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(spfa())&#123;</span><br><span class=\"line\">        minf=oo,now=<span class=\"keyword\">super_t</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(now!=super_s) minf=min(minf,edge[pre[now]].cap-edge[pre[now]].flow),now=edge[pre[now]].from;</span><br><span class=\"line\">        now=<span class=\"keyword\">super_t</span>,ans+=<span class=\"number\">1L</span>L*minf*dis[<span class=\"keyword\">super_t</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(now!=super_s) edge[pre[now]].flow+=minf,edge[pre[now]^<span class=\"number\">1</span>].flow-=minf,now=edge[pre[now]].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t1;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;tot);</span><br><span class=\"line\">    super_s=tot+tot+<span class=\"number\">1</span>,<span class=\"keyword\">super_t</span>=tot+tot+<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t1);</span><br><span class=\"line\">        add_edge(super_s,i,t1,<span class=\"number\">0</span>);</span><br><span class=\"line\">        add_edge(i+tot,<span class=\"keyword\">super_t</span>,t1,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;tot) add_edge(i+tot,i+tot+<span class=\"number\">1</span>,oo,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d%d\"</span>,&amp;p,&amp;m,&amp;f,&amp;n,&amp;s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot-m;i++) add_edge(i,i+m+tot,oo,f);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot-n;i++) add_edge(i,i+n+tot,oo,s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++) add_edge(super_s,i+tot,oo,p);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\"</span>,mincostflow());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"「luogu2714」四元组统计","slug":"「luogu2714」四元组统计"},"next":{"title":"「luogu2764」最小路径覆盖问题","slug":"「luogu2764」最小路径覆盖问题"},"link":"/2018/03/08","toc":[{"title":"题目大意","id":"题目大意","index":"1"},{"title":"解析","id":"解析","index":"2"},{"title":"代码","id":"代码","index":"3"}]}